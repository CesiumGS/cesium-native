const fs = require("fs");
const path = require("path");

const getNameFromTitle = require("./getNameFromTitle");
const unindent = require("./unindent");

function generateRegisterExtensions(options) {
  const {
    readerOutputDir,
    writerOutputDir,
    config,
    namespace,
    readerNamespace,
    writerNamespace,
    rootSchema,
    extensions,
  } = options;

  const classNames = [];
  const extensionClassNames = [];
  const registrations = [];

  for (const title in extensions) {
    const className = getNameFromTitle(config, title);
    classNames.push(className);

    const extensionsList = extensions[title];
    for (const extension of extensionsList) {
      const extensionClassName = extension.className;
      extensionClassNames.push(extensionClassName);
      registrations.push({
        className,
        extensionClassName,
      });
    }
  }

  const rootSchemaName = getNameFromTitle(config, rootSchema.title);

  const readerFilename = "registerReaderExtensions";
  const writerFilename = "registerWriterExtensions";

  const readerHeader = `
        // This file was generated by generate-classes.
        // DO NOT EDIT THIS FILE!
        #pragma once

        namespace CesiumJsonReader {
        class JsonReaderOptions;
        } // namespace CesiumJsonReader

        namespace ${readerNamespace} {
        void registerReaderExtensions(CesiumJsonReader::JsonReaderOptions& options);
        } // namespace ${readerNamespace}
  `;

  const readerImplementation = `
        // This file was generated by generate-classes.
        // DO NOT EDIT THIS FILE!

        #include "${readerFilename}.h"

        #include <CesiumJsonReader/JsonReaderOptions.h>

        ${classNames
          .map((className) => {
            return `#include <${namespace}/${className}.h>`;
          })
          .join("\n")}

        ${extensionClassNames
          .map((extensionClassName) => {
            return `#include "${extensionClassName}JsonHandler.h"`;
          })
          .join("\n")}

        namespace ${readerNamespace} {

        void registerReaderExtensions(CesiumJsonReader::JsonReaderOptions& options) {
          (void)options;
          ${registrations
            .map((registration) => {
              return `options.registerExtension<${namespace}::${registration.className}, ${registration.extensionClassName}JsonHandler>();`;
            })
            .join("\n")}
        }
        } // namespace ${readerNamespace}
  `;

  const writerHeader = `
        // This file was generated by generate-classes.
        // DO NOT EDIT THIS FILE!
        #pragma once

        namespace CesiumJsonWriter {
        class ExtensionWriterContext;
        } // namespace CesiumJsonWriter

        namespace ${writerNamespace} {
        void registerWriterExtensions(CesiumJsonWriter::ExtensionWriterContext& context);
        } // namespace ${writerNamespace}
  `;

  const writerImplementation = `
        // This file was generated by generate-classes.
        // DO NOT EDIT THIS FILE!

        #include "${writerFilename}.h"

        #include "${rootSchemaName}JsonWriter.h"

        #include <CesiumJsonWriter/ExtensionWriterContext.h>

        ${classNames
          .map((className) => {
            return `#include <${namespace}/${className}.h>`;
          })
          .join("\n")}

        ${
          extensionClassNames.length > 0
            ? "// NOLINTBEGIN(misc-include-cleaner)"
            : ""
        }
        ${extensionClassNames
          .map((extensionClassName) => {
            return `#include <${namespace}/${extensionClassName}.h>`;
          })
          .join("\n")}
        ${
          extensionClassNames.length > 0
            ? "// NOLINTEND(misc-include-cleaner)"
            : ""
        }

        namespace ${writerNamespace} {

        void registerWriterExtensions(CesiumJsonWriter::ExtensionWriterContext& context) {
          (void)context;
          ${registrations
            .map((registration) => {
              return `context.registerExtension<${namespace}::${registration.className}, ${registration.extensionClassName}JsonWriter>();`;
            })
            .join("\n")}
        }
        } // namespace ${writerNamespace}
  `;

  const readerHeaderOutputDir = path.join(readerOutputDir, "generated", "src");
  fs.mkdirSync(readerHeaderOutputDir, { recursive: true });
  const readerHeaderOutputPath = path.join(
    readerHeaderOutputDir,
    `${readerFilename}.h`
  );
  const readerImplementationOutputPath = path.join(
    readerHeaderOutputDir,
    `${readerFilename}.cpp`
  );
  fs.writeFileSync(readerHeaderOutputPath, unindent(readerHeader), "utf-8");
  fs.writeFileSync(
    readerImplementationOutputPath,
    unindent(readerImplementation),
    "utf-8"
  );

  const writerHeaderOutputDir = path.join(writerOutputDir, "generated", "src");
  fs.mkdirSync(writerHeaderOutputDir, { recursive: true });
  const writerHeaderOutputPath = path.join(
    writerHeaderOutputDir,
    `${writerFilename}.h`
  );
  const writerImplementationOutputPath = path.join(
    writerHeaderOutputDir,
    `${writerFilename}.cpp`
  );
  fs.writeFileSync(writerHeaderOutputPath, unindent(writerHeader), "utf-8");
  fs.writeFileSync(
    writerImplementationOutputPath,
    unindent(writerImplementation),
    "utf-8"
  );
}

module.exports = generateRegisterExtensions;
