// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionKhrDracoMeshCompressionJsonHandler.h"

#include <CesiumGltf/ExtensionKhrDracoMeshCompression.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionKhrDracoMeshCompressionJsonHandler::
    ExtensionKhrDracoMeshCompressionJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _bufferView(),
      _attributes() {}

void ExtensionKhrDracoMeshCompressionJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionKhrDracoMeshCompression* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionKhrDracoMeshCompressionJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionKhrDracoMeshCompression(
      CesiumGltf::ExtensionKhrDracoMeshCompression::TypeName,
      str,
      *this->_pObject);
}

void ExtensionKhrDracoMeshCompressionJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            CesiumGltf::ExtensionKhrDracoMeshCompression())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionKhrDracoMeshCompression&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionKhrDracoMeshCompressionJsonHandler::
    readObjectKeyExtensionKhrDracoMeshCompression(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionKhrDracoMeshCompression& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("attributes"s == str)
    return property("attributes", this->_attributes, o.attributes);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionKhrMaterialsUnlitJsonHandler.h"

#include <CesiumGltf/ExtensionKhrMaterialsUnlit.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionKhrMaterialsUnlitJsonHandler::ExtensionKhrMaterialsUnlitJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context) {}

void ExtensionKhrMaterialsUnlitJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionKhrMaterialsUnlit* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionKhrMaterialsUnlitJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionKhrMaterialsUnlit(
      CesiumGltf::ExtensionKhrMaterialsUnlit::TypeName,
      str,
      *this->_pObject);
}

void ExtensionKhrMaterialsUnlitJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, CesiumGltf::ExtensionKhrMaterialsUnlit())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionKhrMaterialsUnlit&>(value));
}

CesiumJsonReader::IJsonHandler*
ExtensionKhrMaterialsUnlitJsonHandler::readObjectKeyExtensionKhrMaterialsUnlit(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::ExtensionKhrMaterialsUnlit& o) {
  using namespace std::string_literals;

  (void)o;

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtMeshGpuInstancingJsonHandler.h"

#include <CesiumGltf/ExtensionExtMeshGpuInstancing.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtMeshGpuInstancingJsonHandler::
    ExtensionExtMeshGpuInstancingJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _attributes() {}

void ExtensionExtMeshGpuInstancingJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtMeshGpuInstancing* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshGpuInstancingJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtMeshGpuInstancing(
      CesiumGltf::ExtensionExtMeshGpuInstancing::TypeName,
      str,
      *this->_pObject);
}

void ExtensionExtMeshGpuInstancingJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, CesiumGltf::ExtensionExtMeshGpuInstancing())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionExtMeshGpuInstancing&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionExtMeshGpuInstancingJsonHandler::
    readObjectKeyExtensionExtMeshGpuInstancing(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtMeshGpuInstancing& o) {
  using namespace std::string_literals;

  if ("attributes"s == str)
    return property("attributes", this->_attributes, o.attributes);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionBufferExtMeshoptCompressionJsonHandler.h"

#include <CesiumGltf/ExtensionBufferExtMeshoptCompression.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionBufferExtMeshoptCompressionJsonHandler::
    ExtensionBufferExtMeshoptCompressionJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _fallback() {}

void ExtensionBufferExtMeshoptCompressionJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionBufferExtMeshoptCompression* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionBufferExtMeshoptCompressionJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionBufferExtMeshoptCompression(
      CesiumGltf::ExtensionBufferExtMeshoptCompression::TypeName,
      str,
      *this->_pObject);
}

void ExtensionBufferExtMeshoptCompressionJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            CesiumGltf::ExtensionBufferExtMeshoptCompression())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionBufferExtMeshoptCompression&>(value));
}

CesiumJsonReader::IJsonHandler*
ExtensionBufferExtMeshoptCompressionJsonHandler::
    readObjectKeyExtensionBufferExtMeshoptCompression(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionBufferExtMeshoptCompression& o) {
  using namespace std::string_literals;

  if ("fallback"s == str)
    return property("fallback", this->_fallback, o.fallback);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionBufferViewExtMeshoptCompressionJsonHandler.h"

#include <CesiumGltf/ExtensionBufferViewExtMeshoptCompression.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionBufferViewExtMeshoptCompressionJsonHandler::
    ExtensionBufferViewExtMeshoptCompressionJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _buffer(),
      _byteOffset(),
      _byteLength(),
      _byteStride(),
      _count(),
      _mode(),
      _filter() {}

void ExtensionBufferViewExtMeshoptCompressionJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionBufferViewExtMeshoptCompression* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionBufferViewExtMeshoptCompressionJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionBufferViewExtMeshoptCompression(
      CesiumGltf::ExtensionBufferViewExtMeshoptCompression::TypeName,
      str,
      *this->_pObject);
}

void ExtensionBufferViewExtMeshoptCompressionJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(
              extensionName,
              CesiumGltf::ExtensionBufferViewExtMeshoptCompression())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionBufferViewExtMeshoptCompression&>(
          value));
}

CesiumJsonReader::IJsonHandler*
ExtensionBufferViewExtMeshoptCompressionJsonHandler::
    readObjectKeyExtensionBufferViewExtMeshoptCompression(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionBufferViewExtMeshoptCompression& o) {
  using namespace std::string_literals;

  if ("buffer"s == str)
    return property("buffer", this->_buffer, o.buffer);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("byteStride"s == str)
    return property("byteStride", this->_byteStride, o.byteStride);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("mode"s == str)
    return property("mode", this->_mode, o.mode);
  if ("filter"s == str)
    return property("filter", this->_filter, o.filter);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionModelExtFeatureMetadataJsonHandler.h"

#include <CesiumGltf/ExtensionModelExtFeatureMetadata.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionModelExtFeatureMetadataJsonHandler::
    ExtensionModelExtFeatureMetadataJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _schema(context),
      _schemaUri(),
      _statistics(context),
      _featureTables(context),
      _featureTextures(context) {}

void ExtensionModelExtFeatureMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionModelExtFeatureMetadata* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionModelExtFeatureMetadataJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionModelExtFeatureMetadata(
      CesiumGltf::ExtensionModelExtFeatureMetadata::TypeName,
      str,
      *this->_pObject);
}

void ExtensionModelExtFeatureMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            CesiumGltf::ExtensionModelExtFeatureMetadata())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionModelExtFeatureMetadata&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionModelExtFeatureMetadataJsonHandler::
    readObjectKeyExtensionModelExtFeatureMetadata(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionModelExtFeatureMetadata& o) {
  using namespace std::string_literals;

  if ("schema"s == str)
    return property("schema", this->_schema, o.schema);
  if ("schemaUri"s == str)
    return property("schemaUri", this->_schemaUri, o.schemaUri);
  if ("statistics"s == str)
    return property("statistics", this->_statistics, o.statistics);
  if ("featureTables"s == str)
    return property("featureTables", this->_featureTables, o.featureTables);
  if ("featureTextures"s == str)
    return property(
        "featureTextures",
        this->_featureTextures,
        o.featureTextures);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler.h"

#include <CesiumGltf/ExtensionMeshPrimitiveExtFeatureMetadata.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler::
    ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _featureIdAttributes(context),
      _featureIdTextures(context),
      _featureTextures() {}

void ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionMeshPrimitiveExtFeatureMetadata* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionMeshPrimitiveExtFeatureMetadata(
      CesiumGltf::ExtensionMeshPrimitiveExtFeatureMetadata::TypeName,
      str,
      *this->_pObject);
}

void ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(
              extensionName,
              CesiumGltf::ExtensionMeshPrimitiveExtFeatureMetadata())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionMeshPrimitiveExtFeatureMetadata&>(
          value));
}

CesiumJsonReader::IJsonHandler*
ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler::
    readObjectKeyExtensionMeshPrimitiveExtFeatureMetadata(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionMeshPrimitiveExtFeatureMetadata& o) {
  using namespace std::string_literals;

  if ("featureIdAttributes"s == str)
    return property(
        "featureIdAttributes",
        this->_featureIdAttributes,
        o.featureIdAttributes);
  if ("featureIdTextures"s == str)
    return property(
        "featureIdTextures",
        this->_featureIdTextures,
        o.featureIdTextures);
  if ("featureTextures"s == str)
    return property(
        "featureTextures",
        this->_featureTextures,
        o.featureTextures);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
<<<<<<< HEAD
#include "ExtensionTextureBasisUJsonHandler.h"

#include <CesiumGltf/ExtensionTextureBasisU.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionTextureBasisUJsonHandler::ExtensionTextureBasisUJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _source() {}

void ExtensionTextureBasisUJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionTextureBasisU* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionTextureBasisUJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionTextureBasisU(
      CesiumGltf::ExtensionTextureBasisU::TypeName,
      str,
      *this->_pObject);
}

void ExtensionTextureBasisUJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions.emplace(extensionName, CesiumGltf::ExtensionTextureBasisU())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionTextureBasisU&>(value));
}

CesiumJsonReader::IJsonHandler*
ExtensionTextureBasisUJsonHandler::readObjectKeyExtensionTextureBasisU(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::ExtensionTextureBasisU& o) {
  using namespace std::string_literals;

  if ("source"s == str)
    return property("source", this->_source, o.source);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "FeatureIDTextureJsonHandler.h"
=======
#include "ExtensionCesiumTileEdgesJsonHandler.h"
>>>>>>> main

#include <CesiumGltf/ExtensionCesiumTileEdges.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionCesiumTileEdgesJsonHandler::ExtensionCesiumTileEdgesJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _left(),
      _bottom(),
      _right(),
      _top() {}

void ExtensionCesiumTileEdgesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionCesiumTileEdges* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionCesiumTileEdgesJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionCesiumTileEdges(
      CesiumGltf::ExtensionCesiumTileEdges::TypeName,
      str,
      *this->_pObject);
}

void ExtensionCesiumTileEdgesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, CesiumGltf::ExtensionCesiumTileEdges())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionCesiumTileEdges&>(value));
}

CesiumJsonReader::IJsonHandler*
ExtensionCesiumTileEdgesJsonHandler::readObjectKeyExtensionCesiumTileEdges(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::ExtensionCesiumTileEdges& o) {
  using namespace std::string_literals;

  if ("left"s == str)
    return property("left", this->_left, o.left);
  if ("bottom"s == str)
    return property("bottom", this->_bottom, o.bottom);
  if ("right"s == str)
    return property("right", this->_right, o.right);
  if ("top"s == str)
    return property("top", this->_top, o.top);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionModelExtMeshFeaturesJsonHandler.h"

#include <CesiumGltf/ExtensionModelExtMeshFeatures.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionModelExtMeshFeaturesJsonHandler::
    ExtensionModelExtMeshFeaturesJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _schema(context),
      _schemaUri(),
      _propertyTables(context),
      _propertyTextures(context) {}

void ExtensionModelExtMeshFeaturesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionModelExtMeshFeatures* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionModelExtMeshFeaturesJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionModelExtMeshFeatures(
      CesiumGltf::ExtensionModelExtMeshFeatures::TypeName,
      str,
      *this->_pObject);
}

void ExtensionModelExtMeshFeaturesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, CesiumGltf::ExtensionModelExtMeshFeatures())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionModelExtMeshFeatures&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionModelExtMeshFeaturesJsonHandler::
    readObjectKeyExtensionModelExtMeshFeatures(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionModelExtMeshFeatures& o) {
  using namespace std::string_literals;

  if ("schema"s == str)
    return property("schema", this->_schema, o.schema);
  if ("schemaUri"s == str)
    return property("schemaUri", this->_schemaUri, o.schemaUri);
  if ("propertyTables"s == str)
    return property("propertyTables", this->_propertyTables, o.propertyTables);
  if ("propertyTextures"s == str)
    return property(
        "propertyTextures",
        this->_propertyTextures,
        o.propertyTextures);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionMeshPrimitiveExtMeshFeaturesJsonHandler.h"

#include <CesiumGltf/ExtensionMeshPrimitiveExtMeshFeatures.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionMeshPrimitiveExtMeshFeaturesJsonHandler::
    ExtensionMeshPrimitiveExtMeshFeaturesJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _featureIds(context),
      _propertyTables(),
      _propertyTextures() {}

void ExtensionMeshPrimitiveExtMeshFeaturesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionMeshPrimitiveExtMeshFeatures* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionMeshPrimitiveExtMeshFeaturesJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionMeshPrimitiveExtMeshFeatures(
      CesiumGltf::ExtensionMeshPrimitiveExtMeshFeatures::TypeName,
      str,
      *this->_pObject);
}

void ExtensionMeshPrimitiveExtMeshFeaturesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            CesiumGltf::ExtensionMeshPrimitiveExtMeshFeatures())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionMeshPrimitiveExtMeshFeatures&>(
          value));
}

CesiumJsonReader::IJsonHandler*
ExtensionMeshPrimitiveExtMeshFeaturesJsonHandler::
    readObjectKeyExtensionMeshPrimitiveExtMeshFeatures(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionMeshPrimitiveExtMeshFeatures& o) {
  using namespace std::string_literals;

  if ("featureIds"s == str)
    return property("featureIds", this->_featureIds, o.featureIds);
  if ("propertyTables"s == str)
    return property("propertyTables", this->_propertyTables, o.propertyTables);
  if ("propertyTextures"s == str)
    return property(
        "propertyTextures",
        this->_propertyTextures,
        o.propertyTextures);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionNodeExtMeshFeaturesJsonHandler.h"

#include <CesiumGltf/ExtensionNodeExtMeshFeatures.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionNodeExtMeshFeaturesJsonHandler::
    ExtensionNodeExtMeshFeaturesJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _featureIds(context),
      _propertyTables() {}

void ExtensionNodeExtMeshFeaturesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionNodeExtMeshFeatures* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionNodeExtMeshFeaturesJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionNodeExtMeshFeatures(
      CesiumGltf::ExtensionNodeExtMeshFeatures::TypeName,
      str,
      *this->_pObject);
}

void ExtensionNodeExtMeshFeaturesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, CesiumGltf::ExtensionNodeExtMeshFeatures())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<CesiumGltf::ExtensionNodeExtMeshFeatures&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionNodeExtMeshFeaturesJsonHandler::
    readObjectKeyExtensionNodeExtMeshFeatures(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionNodeExtMeshFeatures& o) {
  using namespace std::string_literals;

  if ("featureIds"s == str)
    return property("featureIds", this->_featureIds, o.featureIds);
  if ("propertyTables"s == str)
    return property("propertyTables", this->_propertyTables, o.propertyTables);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtMeshFeaturesFeatureIdJsonHandler.h"

#include <CesiumGltf/ExtensionExtMeshFeaturesFeatureId.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtMeshFeaturesFeatureIdJsonHandler::
    ExtensionExtMeshFeaturesFeatureIdJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : TextureInfoJsonHandler(context),
      _attribute(),
      _offset(),
      _repeat(),
      _channel() {}

void ExtensionExtMeshFeaturesFeatureIdJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtMeshFeaturesFeatureId* pObject) {
  TextureInfoJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshFeaturesFeatureIdJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtMeshFeaturesFeatureId(
      CesiumGltf::ExtensionExtMeshFeaturesFeatureId::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ExtensionExtMeshFeaturesFeatureIdJsonHandler::
    readObjectKeyExtensionExtMeshFeaturesFeatureId(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtMeshFeaturesFeatureId& o) {
  using namespace std::string_literals;

  if ("attribute"s == str)
    return property("attribute", this->_attribute, o.attribute);
  if ("offset"s == str)
    return property("offset", this->_offset, o.offset);
  if ("repeat"s == str)
    return property("repeat", this->_repeat, o.repeat);
  if ("channel"s == str)
    return property("channel", this->_channel, o.channel);

  return this->readObjectKeyTextureInfo(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TextureInfoJsonHandler.h"

#include <CesiumGltf/TextureInfo.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

TextureInfoJsonHandler::TextureInfoJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _index(),
      _texCoord() {}

void TextureInfoJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::TextureInfo* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TextureInfoJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTextureInfo(
      CesiumGltf::TextureInfo::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
TextureInfoJsonHandler::readObjectKeyTextureInfo(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::TextureInfo& o) {
  using namespace std::string_literals;

  if ("index"s == str)
    return property("index", this->_index, o.index);
  if ("texCoord"s == str)
    return property("texCoord", this->_texCoord, o.texCoord);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtMeshFeaturesPropertyTextureJsonHandler.h"

#include <CesiumGltf/ExtensionExtMeshFeaturesPropertyTexture.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtMeshFeaturesPropertyTextureJsonHandler::
    ExtensionExtMeshFeaturesPropertyTextureJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : TextureInfoJsonHandler(context),
      _name(),
      _classProperty(),
      _properties() {}

void ExtensionExtMeshFeaturesPropertyTextureJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtMeshFeaturesPropertyTexture* pObject) {
  TextureInfoJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshFeaturesPropertyTextureJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtMeshFeaturesPropertyTexture(
      CesiumGltf::ExtensionExtMeshFeaturesPropertyTexture::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshFeaturesPropertyTextureJsonHandler::
    readObjectKeyExtensionExtMeshFeaturesPropertyTexture(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtMeshFeaturesPropertyTexture& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyTextureInfo(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtMeshFeaturesPropertyTableJsonHandler.h"

#include <CesiumGltf/ExtensionExtMeshFeaturesPropertyTable.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtMeshFeaturesPropertyTableJsonHandler::
    ExtensionExtMeshFeaturesPropertyTableJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _classProperty(),
      _count(),
      _properties(context) {}

void ExtensionExtMeshFeaturesPropertyTableJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtMeshFeaturesPropertyTable* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshFeaturesPropertyTableJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtMeshFeaturesPropertyTable(
      CesiumGltf::ExtensionExtMeshFeaturesPropertyTable::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshFeaturesPropertyTableJsonHandler::
    readObjectKeyExtensionExtMeshFeaturesPropertyTable(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtMeshFeaturesPropertyTable& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtMeshFeaturesPropertyTablePropertyJsonHandler.h"

#include <CesiumGltf/ExtensionExtMeshFeaturesPropertyTableProperty.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtMeshFeaturesPropertyTablePropertyJsonHandler::
    ExtensionExtMeshFeaturesPropertyTablePropertyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _bufferView(),
      _arrayOffsetType(),
      _arrayOffsetBufferView(),
      _stringOffsetType(),
      _stringOffsetBufferView() {}

void ExtensionExtMeshFeaturesPropertyTablePropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtMeshFeaturesPropertyTableProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshFeaturesPropertyTablePropertyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtMeshFeaturesPropertyTableProperty(
      CesiumGltf::ExtensionExtMeshFeaturesPropertyTableProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshFeaturesPropertyTablePropertyJsonHandler::
    readObjectKeyExtensionExtMeshFeaturesPropertyTableProperty(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtMeshFeaturesPropertyTableProperty& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("arrayOffsetType"s == str)
    return property(
        "arrayOffsetType",
        this->_arrayOffsetType,
        o.arrayOffsetType);
  if ("arrayOffsetBufferView"s == str)
    return property(
        "arrayOffsetBufferView",
        this->_arrayOffsetBufferView,
        o.arrayOffsetBufferView);
  if ("stringOffsetType"s == str)
    return property(
        "stringOffsetType",
        this->_stringOffsetType,
        o.stringOffsetType);
  if ("stringOffsetBufferView"s == str)
    return property(
        "stringOffsetBufferView",
        this->_stringOffsetBufferView,
        o.stringOffsetBufferView);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtMeshFeaturesSchemaJsonHandler.h"

#include <CesiumGltf/ExtensionExtMeshFeaturesSchema.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtMeshFeaturesSchemaJsonHandler::
    ExtensionExtMeshFeaturesSchemaJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _id(),
      _name(),
      _description(),
      _version(),
      _classes(context),
      _enums(context) {}

void ExtensionExtMeshFeaturesSchemaJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtMeshFeaturesSchema* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshFeaturesSchemaJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtMeshFeaturesSchema(
      CesiumGltf::ExtensionExtMeshFeaturesSchema::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ExtensionExtMeshFeaturesSchemaJsonHandler::
    readObjectKeyExtensionExtMeshFeaturesSchema(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtMeshFeaturesSchema& o) {
  using namespace std::string_literals;

  if ("id"s == str)
    return property("id", this->_id, o.id);
  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("classes"s == str)
    return property("classes", this->_classes, o.classes);
  if ("enums"s == str)
    return property("enums", this->_enums, o.enums);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtMeshFeaturesEnumJsonHandler.h"

#include <CesiumGltf/ExtensionExtMeshFeaturesEnum.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtMeshFeaturesEnumJsonHandler::
    ExtensionExtMeshFeaturesEnumJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _valueType(),
      _values(context) {}

void ExtensionExtMeshFeaturesEnumJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtMeshFeaturesEnum* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshFeaturesEnumJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtMeshFeaturesEnum(
      CesiumGltf::ExtensionExtMeshFeaturesEnum::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ExtensionExtMeshFeaturesEnumJsonHandler::
    readObjectKeyExtensionExtMeshFeaturesEnum(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtMeshFeaturesEnum& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("valueType"s == str)
    return property("valueType", this->_valueType, o.valueType);
  if ("values"s == str)
    return property("values", this->_values, o.values);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtMeshFeaturesEnumValueJsonHandler.h"

#include <CesiumGltf/ExtensionExtMeshFeaturesEnumValue.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtMeshFeaturesEnumValueJsonHandler::
    ExtensionExtMeshFeaturesEnumValueJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _value() {}

void ExtensionExtMeshFeaturesEnumValueJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtMeshFeaturesEnumValue* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshFeaturesEnumValueJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtMeshFeaturesEnumValue(
      CesiumGltf::ExtensionExtMeshFeaturesEnumValue::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ExtensionExtMeshFeaturesEnumValueJsonHandler::
    readObjectKeyExtensionExtMeshFeaturesEnumValue(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtMeshFeaturesEnumValue& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("value"s == str)
    return property("value", this->_value, o.value);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtMeshFeaturesClassJsonHandler.h"

#include <CesiumGltf/ExtensionExtMeshFeaturesClass.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtMeshFeaturesClassJsonHandler::
    ExtensionExtMeshFeaturesClassJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _properties(context) {}

void ExtensionExtMeshFeaturesClassJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtMeshFeaturesClass* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshFeaturesClassJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtMeshFeaturesClass(
      CesiumGltf::ExtensionExtMeshFeaturesClass::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ExtensionExtMeshFeaturesClassJsonHandler::
    readObjectKeyExtensionExtMeshFeaturesClass(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtMeshFeaturesClass& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionExtMeshFeaturesClassPropertyJsonHandler.h"

#include <CesiumGltf/ExtensionExtMeshFeaturesClassProperty.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ExtensionExtMeshFeaturesClassPropertyJsonHandler::
    ExtensionExtMeshFeaturesClassPropertyJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _type(),
      _enumType(),
      _componentType(),
      _componentCount(),
      _normalized(),
      _max(),
      _min(),
      _required(),
      _noData(),
      _semantic() {}

void ExtensionExtMeshFeaturesClassPropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ExtensionExtMeshFeaturesClassProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshFeaturesClassPropertyJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionExtMeshFeaturesClassProperty(
      CesiumGltf::ExtensionExtMeshFeaturesClassProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ExtensionExtMeshFeaturesClassPropertyJsonHandler::
    readObjectKeyExtensionExtMeshFeaturesClassProperty(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::ExtensionExtMeshFeaturesClassProperty& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("type"s == str)
    return property("type", this->_type, o.type);
  if ("enumType"s == str)
    return property("enumType", this->_enumType, o.enumType);
  if ("componentType"s == str)
    return property("componentType", this->_componentType, o.componentType);
  if ("componentCount"s == str)
    return property("componentCount", this->_componentCount, o.componentCount);
  if ("normalized"s == str)
    return property("normalized", this->_normalized, o.normalized);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("required"s == str)
    return property("required", this->_required, o.required);
  if ("noData"s == str)
    return property("noData", this->_noData, o.noData);
  if ("semantic"s == str)
    return property("semantic", this->_semantic, o.semantic);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "FeatureIDTextureJsonHandler.h"

#include <CesiumGltf/FeatureIDTexture.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

FeatureIDTextureJsonHandler::FeatureIDTextureJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _featureTable(),
      _featureIds(context) {}

void FeatureIDTextureJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::FeatureIDTexture* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
FeatureIDTextureJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyFeatureIDTexture(
      CesiumGltf::FeatureIDTexture::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
FeatureIDTextureJsonHandler::readObjectKeyFeatureIDTexture(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::FeatureIDTexture& o) {
  using namespace std::string_literals;

  if ("featureTable"s == str)
    return property("featureTable", this->_featureTable, o.featureTable);
  if ("featureIds"s == str)
    return property("featureIds", this->_featureIds, o.featureIds);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TextureAccessorJsonHandler.h"

#include <CesiumGltf/TextureAccessor.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

TextureAccessorJsonHandler::TextureAccessorJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _channels(),
      _texture(context) {}

void TextureAccessorJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::TextureAccessor* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TextureAccessorJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTextureAccessor(
      CesiumGltf::TextureAccessor::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
TextureAccessorJsonHandler::readObjectKeyTextureAccessor(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::TextureAccessor& o) {
  using namespace std::string_literals;

  if ("channels"s == str)
    return property("channels", this->_channels, o.channels);
  if ("texture"s == str)
    return property("texture", this->_texture, o.texture);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "FeatureIDAttributeJsonHandler.h"

#include <CesiumGltf/FeatureIDAttribute.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

FeatureIDAttributeJsonHandler::FeatureIDAttributeJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _featureTable(),
      _featureIds(context) {}

void FeatureIDAttributeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::FeatureIDAttribute* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
FeatureIDAttributeJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyFeatureIDAttribute(
      CesiumGltf::FeatureIDAttribute::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
FeatureIDAttributeJsonHandler::readObjectKeyFeatureIDAttribute(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::FeatureIDAttribute& o) {
  using namespace std::string_literals;

  if ("featureTable"s == str)
    return property("featureTable", this->_featureTable, o.featureTable);
  if ("featureIds"s == str)
    return property("featureIds", this->_featureIds, o.featureIds);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "FeatureIDsJsonHandler.h"

#include <CesiumGltf/FeatureIDs.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

FeatureIDsJsonHandler::FeatureIDsJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _attribute(),
      _constant(),
      _divisor() {}

void FeatureIDsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::FeatureIDs* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
FeatureIDsJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyFeatureIDs(
      CesiumGltf::FeatureIDs::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* FeatureIDsJsonHandler::readObjectKeyFeatureIDs(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::FeatureIDs& o) {
  using namespace std::string_literals;

  if ("attribute"s == str)
    return property("attribute", this->_attribute, o.attribute);
  if ("constant"s == str)
    return property("constant", this->_constant, o.constant);
  if ("divisor"s == str)
    return property("divisor", this->_divisor, o.divisor);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "FeatureTextureJsonHandler.h"

#include <CesiumGltf/FeatureTexture.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

FeatureTextureJsonHandler::FeatureTextureJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _classProperty(),
      _properties(context) {}

void FeatureTextureJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::FeatureTexture* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
FeatureTextureJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyFeatureTexture(
      CesiumGltf::FeatureTexture::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
FeatureTextureJsonHandler::readObjectKeyFeatureTexture(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::FeatureTexture& o) {
  using namespace std::string_literals;

  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "FeatureTableJsonHandler.h"

#include <CesiumGltf/FeatureTable.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

FeatureTableJsonHandler::FeatureTableJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _classProperty(),
      _count(),
      _properties(context) {}

void FeatureTableJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::FeatureTable* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
FeatureTableJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyFeatureTable(
      CesiumGltf::FeatureTable::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
FeatureTableJsonHandler::readObjectKeyFeatureTable(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::FeatureTable& o) {
  using namespace std::string_literals;

  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "FeatureTablePropertyJsonHandler.h"

#include <CesiumGltf/FeatureTableProperty.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

FeatureTablePropertyJsonHandler::FeatureTablePropertyJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _bufferView(),
      _offsetType(),
      _arrayOffsetBufferView(),
      _stringOffsetBufferView() {}

void FeatureTablePropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::FeatureTableProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
FeatureTablePropertyJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyFeatureTableProperty(
      CesiumGltf::FeatureTableProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
FeatureTablePropertyJsonHandler::readObjectKeyFeatureTableProperty(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::FeatureTableProperty& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("offsetType"s == str)
    return property("offsetType", this->_offsetType, o.offsetType);
  if ("arrayOffsetBufferView"s == str)
    return property(
        "arrayOffsetBufferView",
        this->_arrayOffsetBufferView,
        o.arrayOffsetBufferView);
  if ("stringOffsetBufferView"s == str)
    return property(
        "stringOffsetBufferView",
        this->_stringOffsetBufferView,
        o.stringOffsetBufferView);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "StatisticsJsonHandler.h"

#include <CesiumGltf/Statistics.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

StatisticsJsonHandler::StatisticsJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _classes(context) {}

void StatisticsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Statistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
StatisticsJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyStatistics(
      CesiumGltf::Statistics::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* StatisticsJsonHandler::readObjectKeyStatistics(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Statistics& o) {
  using namespace std::string_literals;

  if ("classes"s == str)
    return property("classes", this->_classes, o.classes);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassStatisticsJsonHandler.h"

#include <CesiumGltf/ClassStatistics.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ClassStatisticsJsonHandler::ClassStatisticsJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _count(),
      _properties(context) {}

void ClassStatisticsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ClassStatistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ClassStatisticsJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyClassStatistics(
      CesiumGltf::ClassStatistics::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ClassStatisticsJsonHandler::readObjectKeyClassStatistics(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::ClassStatistics& o) {
  using namespace std::string_literals;

  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyStatisticsJsonHandler.h"

#include <CesiumGltf/PropertyStatistics.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

PropertyStatisticsJsonHandler::PropertyStatisticsJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _min(),
      _max(),
      _mean(),
      _median(),
      _standardDeviation(),
      _variance(),
      _sum(),
      _occurrences() {}

void PropertyStatisticsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::PropertyStatistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyStatisticsJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyPropertyStatistics(
      CesiumGltf::PropertyStatistics::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyStatisticsJsonHandler::readObjectKeyPropertyStatistics(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::PropertyStatistics& o) {
  using namespace std::string_literals;

  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("mean"s == str)
    return property("mean", this->_mean, o.mean);
  if ("median"s == str)
    return property("median", this->_median, o.median);
  if ("standardDeviation"s == str)
    return property(
        "standardDeviation",
        this->_standardDeviation,
        o.standardDeviation);
  if ("variance"s == str)
    return property("variance", this->_variance, o.variance);
  if ("sum"s == str)
    return property("sum", this->_sum, o.sum);
  if ("occurrences"s == str)
    return property("occurrences", this->_occurrences, o.occurrences);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SchemaJsonHandler.h"

#include <CesiumGltf/Schema.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

SchemaJsonHandler::SchemaJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _version(),
      _classes(context),
      _enums(context) {}

void SchemaJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Schema* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SchemaJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySchema(
      CesiumGltf::Schema::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SchemaJsonHandler::readObjectKeySchema(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Schema& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("classes"s == str)
    return property("classes", this->_classes, o.classes);
  if ("enums"s == str)
    return property("enums", this->_enums, o.enums);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "EnumJsonHandler.h"

#include <CesiumGltf/Enum.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

EnumJsonHandler::EnumJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _valueType(),
      _values(context) {}

void EnumJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Enum* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
EnumJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyEnum(
      CesiumGltf::Enum::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* EnumJsonHandler::readObjectKeyEnum(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Enum& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("valueType"s == str)
    return property("valueType", this->_valueType, o.valueType);
  if ("values"s == str)
    return property("values", this->_values, o.values);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "EnumValueJsonHandler.h"

#include <CesiumGltf/EnumValue.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

EnumValueJsonHandler::EnumValueJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _value() {}

void EnumValueJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::EnumValue* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
EnumValueJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyEnumValue(
      CesiumGltf::EnumValue::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* EnumValueJsonHandler::readObjectKeyEnumValue(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::EnumValue& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("value"s == str)
    return property("value", this->_value, o.value);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassJsonHandler.h"

#include <CesiumGltf/Class.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ClassJsonHandler::ClassJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _properties(context) {}

void ClassJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Class* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ClassJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyClass(
      CesiumGltf::Class::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ClassJsonHandler::readObjectKeyClass(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Class& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassPropertyJsonHandler.h"

#include <CesiumGltf/ClassProperty.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ClassPropertyJsonHandler::ClassPropertyJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _type(),
      _enumType(),
      _componentType(),
      _componentCount(),
      _normalized(),
      _max(),
      _min(),
      _defaultProperty(),
      _optional(),
      _semantic() {}

void ClassPropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::ClassProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ClassPropertyJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyClassProperty(
      CesiumGltf::ClassProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ClassPropertyJsonHandler::readObjectKeyClassProperty(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::ClassProperty& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("type"s == str)
    return property("type", this->_type, o.type);
  if ("enumType"s == str)
    return property("enumType", this->_enumType, o.enumType);
  if ("componentType"s == str)
    return property("componentType", this->_componentType, o.componentType);
  if ("componentCount"s == str)
    return property("componentCount", this->_componentCount, o.componentCount);
  if ("normalized"s == str)
    return property("normalized", this->_normalized, o.normalized);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("default"s == str)
    return property("default", this->_defaultProperty, o.defaultProperty);
  if ("optional"s == str)
    return property("optional", this->_optional, o.optional);
  if ("semantic"s == str)
    return property("semantic", this->_semantic, o.semantic);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ModelJsonHandler.h"

#include <CesiumGltf/Model.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ModelJsonHandler::ModelJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _extensionsUsed(),
      _extensionsRequired(),
      _accessors(context),
      _animations(context),
      _asset(context),
      _buffers(context),
      _bufferViews(context),
      _cameras(context),
      _images(context),
      _materials(context),
      _meshes(context),
      _nodes(context),
      _samplers(context),
      _scene(),
      _scenes(context),
      _skins(context),
      _textures(context) {}

void ModelJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Model* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ModelJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyModel(
      CesiumGltf::Model::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ModelJsonHandler::readObjectKeyModel(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Model& o) {
  using namespace std::string_literals;

  if ("extensionsUsed"s == str)
    return property("extensionsUsed", this->_extensionsUsed, o.extensionsUsed);
  if ("extensionsRequired"s == str)
    return property(
        "extensionsRequired",
        this->_extensionsRequired,
        o.extensionsRequired);
  if ("accessors"s == str)
    return property("accessors", this->_accessors, o.accessors);
  if ("animations"s == str)
    return property("animations", this->_animations, o.animations);
  if ("asset"s == str)
    return property("asset", this->_asset, o.asset);
  if ("buffers"s == str)
    return property("buffers", this->_buffers, o.buffers);
  if ("bufferViews"s == str)
    return property("bufferViews", this->_bufferViews, o.bufferViews);
  if ("cameras"s == str)
    return property("cameras", this->_cameras, o.cameras);
  if ("images"s == str)
    return property("images", this->_images, o.images);
  if ("materials"s == str)
    return property("materials", this->_materials, o.materials);
  if ("meshes"s == str)
    return property("meshes", this->_meshes, o.meshes);
  if ("nodes"s == str)
    return property("nodes", this->_nodes, o.nodes);
  if ("samplers"s == str)
    return property("samplers", this->_samplers, o.samplers);
  if ("scene"s == str)
    return property("scene", this->_scene, o.scene);
  if ("scenes"s == str)
    return property("scenes", this->_scenes, o.scenes);
  if ("skins"s == str)
    return property("skins", this->_skins, o.skins);
  if ("textures"s == str)
    return property("textures", this->_textures, o.textures);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TextureJsonHandler.h"

#include <CesiumGltf/Texture.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

TextureJsonHandler::TextureJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(context),
      _sampler(),
      _source() {}

void TextureJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Texture* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TextureJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTexture(
      CesiumGltf::Texture::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TextureJsonHandler::readObjectKeyTexture(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Texture& o) {
  using namespace std::string_literals;

  if ("sampler"s == str)
    return property("sampler", this->_sampler, o.sampler);
  if ("source"s == str)
    return property("source", this->_source, o.source);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SkinJsonHandler.h"

#include <CesiumGltf/Skin.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

SkinJsonHandler::SkinJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(context),
      _inverseBindMatrices(),
      _skeleton(),
      _joints() {}

void SkinJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Skin* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SkinJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySkin(
      CesiumGltf::Skin::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SkinJsonHandler::readObjectKeySkin(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Skin& o) {
  using namespace std::string_literals;

  if ("inverseBindMatrices"s == str)
    return property(
        "inverseBindMatrices",
        this->_inverseBindMatrices,
        o.inverseBindMatrices);
  if ("skeleton"s == str)
    return property("skeleton", this->_skeleton, o.skeleton);
  if ("joints"s == str)
    return property("joints", this->_joints, o.joints);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SceneJsonHandler.h"

#include <CesiumGltf/Scene.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

SceneJsonHandler::SceneJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(context), _nodes() {}

void SceneJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Scene* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SceneJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyScene(
      CesiumGltf::Scene::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SceneJsonHandler::readObjectKeyScene(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Scene& o) {
  using namespace std::string_literals;

  if ("nodes"s == str)
    return property("nodes", this->_nodes, o.nodes);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SamplerJsonHandler.h"

#include <CesiumGltf/Sampler.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

SamplerJsonHandler::SamplerJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(context),
      _magFilter(),
      _minFilter(),
      _wrapS(),
      _wrapT() {}

void SamplerJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Sampler* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SamplerJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySampler(
      CesiumGltf::Sampler::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SamplerJsonHandler::readObjectKeySampler(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Sampler& o) {
  using namespace std::string_literals;

  if ("magFilter"s == str)
    return property("magFilter", this->_magFilter, o.magFilter);
  if ("minFilter"s == str)
    return property("minFilter", this->_minFilter, o.minFilter);
  if ("wrapS"s == str)
    return property("wrapS", this->_wrapS, o.wrapS);
  if ("wrapT"s == str)
    return property("wrapT", this->_wrapT, o.wrapT);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "NodeJsonHandler.h"

#include <CesiumGltf/Node.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

NodeJsonHandler::NodeJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(context),
      _camera(),
      _children(),
      _skin(),
      _matrix(),
      _mesh(),
      _rotation(),
      _scale(),
      _translation(),
      _weights() {}

void NodeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Node* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
NodeJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyNode(
      CesiumGltf::Node::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* NodeJsonHandler::readObjectKeyNode(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Node& o) {
  using namespace std::string_literals;

  if ("camera"s == str)
    return property("camera", this->_camera, o.camera);
  if ("children"s == str)
    return property("children", this->_children, o.children);
  if ("skin"s == str)
    return property("skin", this->_skin, o.skin);
  if ("matrix"s == str)
    return property("matrix", this->_matrix, o.matrix);
  if ("mesh"s == str)
    return property("mesh", this->_mesh, o.mesh);
  if ("rotation"s == str)
    return property("rotation", this->_rotation, o.rotation);
  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);
  if ("translation"s == str)
    return property("translation", this->_translation, o.translation);
  if ("weights"s == str)
    return property("weights", this->_weights, o.weights);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MeshJsonHandler.h"

#include <CesiumGltf/Mesh.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

MeshJsonHandler::MeshJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(context),
      _primitives(context),
      _weights() {}

void MeshJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Mesh* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MeshJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMesh(
      CesiumGltf::Mesh::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MeshJsonHandler::readObjectKeyMesh(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Mesh& o) {
  using namespace std::string_literals;

  if ("primitives"s == str)
    return property("primitives", this->_primitives, o.primitives);
  if ("weights"s == str)
    return property("weights", this->_weights, o.weights);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MeshPrimitiveJsonHandler.h"

#include <CesiumGltf/MeshPrimitive.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

MeshPrimitiveJsonHandler::MeshPrimitiveJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _attributes(),
      _indices(),
      _material(),
      _mode(),
      _targets() {}

void MeshPrimitiveJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::MeshPrimitive* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MeshPrimitiveJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMeshPrimitive(
      CesiumGltf::MeshPrimitive::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
MeshPrimitiveJsonHandler::readObjectKeyMeshPrimitive(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::MeshPrimitive& o) {
  using namespace std::string_literals;

  if ("attributes"s == str)
    return property("attributes", this->_attributes, o.attributes);
  if ("indices"s == str)
    return property("indices", this->_indices, o.indices);
  if ("material"s == str)
    return property("material", this->_material, o.material);
  if ("mode"s == str)
    return property("mode", this->_mode, o.mode);
  if ("targets"s == str)
    return property("targets", this->_targets, o.targets);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MaterialJsonHandler.h"

#include <CesiumGltf/Material.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

MaterialJsonHandler::MaterialJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(context),
      _pbrMetallicRoughness(context),
      _normalTexture(context),
      _occlusionTexture(context),
      _emissiveTexture(context),
      _emissiveFactor(),
      _alphaMode(),
      _alphaCutoff(),
      _doubleSided() {}

void MaterialJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Material* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MaterialJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterial(
      CesiumGltf::Material::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MaterialJsonHandler::readObjectKeyMaterial(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Material& o) {
  using namespace std::string_literals;

  if ("pbrMetallicRoughness"s == str)
    return property(
        "pbrMetallicRoughness",
        this->_pbrMetallicRoughness,
        o.pbrMetallicRoughness);
  if ("normalTexture"s == str)
    return property("normalTexture", this->_normalTexture, o.normalTexture);
  if ("occlusionTexture"s == str)
    return property(
        "occlusionTexture",
        this->_occlusionTexture,
        o.occlusionTexture);
  if ("emissiveTexture"s == str)
    return property(
        "emissiveTexture",
        this->_emissiveTexture,
        o.emissiveTexture);
  if ("emissiveFactor"s == str)
    return property("emissiveFactor", this->_emissiveFactor, o.emissiveFactor);
  if ("alphaMode"s == str)
    return property("alphaMode", this->_alphaMode, o.alphaMode);
  if ("alphaCutoff"s == str)
    return property("alphaCutoff", this->_alphaCutoff, o.alphaCutoff);
  if ("doubleSided"s == str)
    return property("doubleSided", this->_doubleSided, o.doubleSided);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MaterialOcclusionTextureInfoJsonHandler.h"

#include <CesiumGltf/MaterialOcclusionTextureInfo.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

MaterialOcclusionTextureInfoJsonHandler::
    MaterialOcclusionTextureInfoJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : TextureInfoJsonHandler(context), _strength() {}

void MaterialOcclusionTextureInfoJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::MaterialOcclusionTextureInfo* pObject) {
  TextureInfoJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MaterialOcclusionTextureInfoJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterialOcclusionTextureInfo(
      CesiumGltf::MaterialOcclusionTextureInfo::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MaterialOcclusionTextureInfoJsonHandler::
    readObjectKeyMaterialOcclusionTextureInfo(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::MaterialOcclusionTextureInfo& o) {
  using namespace std::string_literals;

  if ("strength"s == str)
    return property("strength", this->_strength, o.strength);

  return this->readObjectKeyTextureInfo(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MaterialNormalTextureInfoJsonHandler.h"

#include <CesiumGltf/MaterialNormalTextureInfo.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

MaterialNormalTextureInfoJsonHandler::MaterialNormalTextureInfoJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : TextureInfoJsonHandler(context), _scale() {}

void MaterialNormalTextureInfoJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::MaterialNormalTextureInfo* pObject) {
  TextureInfoJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MaterialNormalTextureInfoJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterialNormalTextureInfo(
      CesiumGltf::MaterialNormalTextureInfo::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
MaterialNormalTextureInfoJsonHandler::readObjectKeyMaterialNormalTextureInfo(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::MaterialNormalTextureInfo& o) {
  using namespace std::string_literals;

  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);

  return this->readObjectKeyTextureInfo(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MaterialPBRMetallicRoughnessJsonHandler.h"

#include <CesiumGltf/MaterialPBRMetallicRoughness.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

MaterialPBRMetallicRoughnessJsonHandler::
    MaterialPBRMetallicRoughnessJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _baseColorFactor(),
      _baseColorTexture(context),
      _metallicFactor(),
      _roughnessFactor(),
      _metallicRoughnessTexture(context) {}

void MaterialPBRMetallicRoughnessJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::MaterialPBRMetallicRoughness* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MaterialPBRMetallicRoughnessJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterialPBRMetallicRoughness(
      CesiumGltf::MaterialPBRMetallicRoughness::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MaterialPBRMetallicRoughnessJsonHandler::
    readObjectKeyMaterialPBRMetallicRoughness(
        const std::string& objectType,
        const std::string_view& str,
        CesiumGltf::MaterialPBRMetallicRoughness& o) {
  using namespace std::string_literals;

  if ("baseColorFactor"s == str)
    return property(
        "baseColorFactor",
        this->_baseColorFactor,
        o.baseColorFactor);
  if ("baseColorTexture"s == str)
    return property(
        "baseColorTexture",
        this->_baseColorTexture,
        o.baseColorTexture);
  if ("metallicFactor"s == str)
    return property("metallicFactor", this->_metallicFactor, o.metallicFactor);
  if ("roughnessFactor"s == str)
    return property(
        "roughnessFactor",
        this->_roughnessFactor,
        o.roughnessFactor);
  if ("metallicRoughnessTexture"s == str)
    return property(
        "metallicRoughnessTexture",
        this->_metallicRoughnessTexture,
        o.metallicRoughnessTexture);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ImageJsonHandler.h"

#include <CesiumGltf/Image.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

ImageJsonHandler::ImageJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(context),
      _uri(),
      _mimeType(),
      _bufferView() {}

void ImageJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Image* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ImageJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyImage(
      CesiumGltf::Image::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ImageJsonHandler::readObjectKeyImage(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Image& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);
  if ("mimeType"s == str)
    return property("mimeType", this->_mimeType, o.mimeType);
  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "CameraJsonHandler.h"

#include <CesiumGltf/Camera.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

CameraJsonHandler::CameraJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(context),
      _orthographic(context),
      _perspective(context),
      _type() {}

void CameraJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Camera* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
CameraJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyCamera(
      CesiumGltf::Camera::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* CameraJsonHandler::readObjectKeyCamera(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Camera& o) {
  using namespace std::string_literals;

  if ("orthographic"s == str)
    return property("orthographic", this->_orthographic, o.orthographic);
  if ("perspective"s == str)
    return property("perspective", this->_perspective, o.perspective);
  if ("type"s == str)
    return property("type", this->_type, o.type);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "CameraPerspectiveJsonHandler.h"

#include <CesiumGltf/CameraPerspective.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

CameraPerspectiveJsonHandler::CameraPerspectiveJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _aspectRatio(),
      _yfov(),
      _zfar(),
      _znear() {}

void CameraPerspectiveJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::CameraPerspective* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
CameraPerspectiveJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyCameraPerspective(
      CesiumGltf::CameraPerspective::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
CameraPerspectiveJsonHandler::readObjectKeyCameraPerspective(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::CameraPerspective& o) {
  using namespace std::string_literals;

  if ("aspectRatio"s == str)
    return property("aspectRatio", this->_aspectRatio, o.aspectRatio);
  if ("yfov"s == str)
    return property("yfov", this->_yfov, o.yfov);
  if ("zfar"s == str)
    return property("zfar", this->_zfar, o.zfar);
  if ("znear"s == str)
    return property("znear", this->_znear, o.znear);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "CameraOrthographicJsonHandler.h"

#include <CesiumGltf/CameraOrthographic.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

CameraOrthographicJsonHandler::CameraOrthographicJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _xmag(),
      _ymag(),
      _zfar(),
      _znear() {}

void CameraOrthographicJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::CameraOrthographic* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
CameraOrthographicJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyCameraOrthographic(
      CesiumGltf::CameraOrthographic::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
CameraOrthographicJsonHandler::readObjectKeyCameraOrthographic(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::CameraOrthographic& o) {
  using namespace std::string_literals;

  if ("xmag"s == str)
    return property("xmag", this->_xmag, o.xmag);
  if ("ymag"s == str)
    return property("ymag", this->_ymag, o.ymag);
  if ("zfar"s == str)
    return property("zfar", this->_zfar, o.zfar);
  if ("znear"s == str)
    return property("znear", this->_znear, o.znear);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferViewJsonHandler.h"

#include <CesiumGltf/BufferView.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

BufferViewJsonHandler::BufferViewJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(context),
      _buffer(),
      _byteOffset(),
      _byteLength(),
      _byteStride(),
      _target() {}

void BufferViewJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::BufferView* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferViewJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBufferView(
      CesiumGltf::BufferView::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferViewJsonHandler::readObjectKeyBufferView(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::BufferView& o) {
  using namespace std::string_literals;

  if ("buffer"s == str)
    return property("buffer", this->_buffer, o.buffer);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("byteStride"s == str)
    return property("byteStride", this->_byteStride, o.byteStride);
  if ("target"s == str)
    return property("target", this->_target, o.target);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferJsonHandler.h"

#include <CesiumGltf/Buffer.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

BufferJsonHandler::BufferJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(context),
      _uri(),
      _byteLength() {}

void BufferJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Buffer* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBuffer(
      CesiumGltf::Buffer::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferJsonHandler::readObjectKeyBuffer(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Buffer& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AssetJsonHandler.h"

#include <CesiumGltf/Asset.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AssetJsonHandler::AssetJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _copyright(),
      _generator(),
      _version(),
      _minVersion() {}

void AssetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Asset* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AssetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAsset(
      CesiumGltf::Asset::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AssetJsonHandler::readObjectKeyAsset(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Asset& o) {
  using namespace std::string_literals;

  if ("copyright"s == str)
    return property("copyright", this->_copyright, o.copyright);
  if ("generator"s == str)
    return property("generator", this->_generator, o.generator);
  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("minVersion"s == str)
    return property("minVersion", this->_minVersion, o.minVersion);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationJsonHandler.h"

#include <CesiumGltf/Animation.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AnimationJsonHandler::AnimationJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(context),
      _channels(context),
      _samplers(context) {}

void AnimationJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Animation* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AnimationJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimation(
      CesiumGltf::Animation::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AnimationJsonHandler::readObjectKeyAnimation(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Animation& o) {
  using namespace std::string_literals;

  if ("channels"s == str)
    return property("channels", this->_channels, o.channels);
  if ("samplers"s == str)
    return property("samplers", this->_samplers, o.samplers);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationSamplerJsonHandler.h"

#include <CesiumGltf/AnimationSampler.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AnimationSamplerJsonHandler::AnimationSamplerJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _input(),
      _interpolation(),
      _output() {}

void AnimationSamplerJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::AnimationSampler* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AnimationSamplerJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimationSampler(
      CesiumGltf::AnimationSampler::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AnimationSamplerJsonHandler::readObjectKeyAnimationSampler(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::AnimationSampler& o) {
  using namespace std::string_literals;

  if ("input"s == str)
    return property("input", this->_input, o.input);
  if ("interpolation"s == str)
    return property("interpolation", this->_interpolation, o.interpolation);
  if ("output"s == str)
    return property("output", this->_output, o.output);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationChannelJsonHandler.h"

#include <CesiumGltf/AnimationChannel.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AnimationChannelJsonHandler::AnimationChannelJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _sampler(),
      _target(context) {}

void AnimationChannelJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::AnimationChannel* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AnimationChannelJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimationChannel(
      CesiumGltf::AnimationChannel::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AnimationChannelJsonHandler::readObjectKeyAnimationChannel(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::AnimationChannel& o) {
  using namespace std::string_literals;

  if ("sampler"s == str)
    return property("sampler", this->_sampler, o.sampler);
  if ("target"s == str)
    return property("target", this->_target, o.target);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationChannelTargetJsonHandler.h"

#include <CesiumGltf/AnimationChannelTarget.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AnimationChannelTargetJsonHandler::AnimationChannelTargetJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _node(),
      _path() {}

void AnimationChannelTargetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::AnimationChannelTarget* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AnimationChannelTargetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimationChannelTarget(
      CesiumGltf::AnimationChannelTarget::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AnimationChannelTargetJsonHandler::readObjectKeyAnimationChannelTarget(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::AnimationChannelTarget& o) {
  using namespace std::string_literals;

  if ("node"s == str)
    return property("node", this->_node, o.node);
  if ("path"s == str)
    return property("path", this->_path, o.path);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorJsonHandler.h"

#include <CesiumGltf/Accessor.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AccessorJsonHandler::AccessorJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumGltfReader::NamedObjectJsonHandler(context),
      _bufferView(),
      _byteOffset(),
      _componentType(),
      _normalized(),
      _count(),
      _type(),
      _max(),
      _min(),
      _sparse(context) {}

void AccessorJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::Accessor* pObject) {
  CesiumGltfReader::NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AccessorJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessor(
      CesiumGltf::Accessor::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AccessorJsonHandler::readObjectKeyAccessor(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::Accessor& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("componentType"s == str)
    return property("componentType", this->_componentType, o.componentType);
  if ("normalized"s == str)
    return property("normalized", this->_normalized, o.normalized);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("type"s == str)
    return property("type", this->_type, o.type);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("sparse"s == str)
    return property("sparse", this->_sparse, o.sparse);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorSparseJsonHandler.h"

#include <CesiumGltf/AccessorSparse.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AccessorSparseJsonHandler::AccessorSparseJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _count(),
      _indices(context),
      _values(context) {}

void AccessorSparseJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::AccessorSparse* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AccessorSparseJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessorSparse(
      CesiumGltf::AccessorSparse::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AccessorSparseJsonHandler::readObjectKeyAccessorSparse(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::AccessorSparse& o) {
  using namespace std::string_literals;

  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("indices"s == str)
    return property("indices", this->_indices, o.indices);
  if ("values"s == str)
    return property("values", this->_values, o.values);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorSparseValuesJsonHandler.h"

#include <CesiumGltf/AccessorSparseValues.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AccessorSparseValuesJsonHandler::AccessorSparseValuesJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _bufferView(),
      _byteOffset() {}

void AccessorSparseValuesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::AccessorSparseValues* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AccessorSparseValuesJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessorSparseValues(
      CesiumGltf::AccessorSparseValues::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AccessorSparseValuesJsonHandler::readObjectKeyAccessorSparseValues(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::AccessorSparseValues& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorSparseIndicesJsonHandler.h"

#include <CesiumGltf/AccessorSparseIndices.h>

#include <cassert>
#include <string>

namespace CesiumGltfReader {

AccessorSparseIndicesJsonHandler::AccessorSparseIndicesJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _bufferView(),
      _byteOffset(),
      _componentType() {}

void AccessorSparseIndicesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumGltf::AccessorSparseIndices* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AccessorSparseIndicesJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessorSparseIndices(
      CesiumGltf::AccessorSparseIndices::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AccessorSparseIndicesJsonHandler::readObjectKeyAccessorSparseIndices(
    const std::string& objectType,
    const std::string_view& str,
    CesiumGltf::AccessorSparseIndices& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str)
    return property("bufferView", this->_bufferView, o.bufferView);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("componentType"s == str)
    return property("componentType", this->_componentType, o.componentType);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace CesiumGltfReader
