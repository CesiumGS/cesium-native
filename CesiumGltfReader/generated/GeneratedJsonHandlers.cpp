// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionKhrDracoMeshCompressionJsonHandler.h"
#include <CesiumGltf/ExtensionKhrDracoMeshCompression.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

ExtensionKhrDracoMeshCompressionJsonHandler::ExtensionKhrDracoMeshCompressionJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _bufferView(), _attributes() {}

void ExtensionKhrDracoMeshCompressionJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, ExtensionKhrDracoMeshCompression* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* ExtensionKhrDracoMeshCompressionJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionKhrDracoMeshCompression(ExtensionKhrDracoMeshCompression::TypeName, str, *this->_pObject);
}

void ExtensionKhrDracoMeshCompressionJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, CesiumUtility::ExtensibleObject& o, const std::string_view& extensionName) {
  std::any& value =
      o.extensions.emplace(extensionName, ExtensionKhrDracoMeshCompression())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<ExtensionKhrDracoMeshCompression&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionKhrDracoMeshCompressionJsonHandler::readObjectKeyExtensionKhrDracoMeshCompression(const std::string& objectType, const std::string_view& str, ExtensionKhrDracoMeshCompression& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str) return property("bufferView", this->_bufferView, o.bufferView);
  if ("attributes"s == str) return property("attributes", this->_attributes, o.attributes);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionModelExtFeatureMetadataJsonHandler.h"
#include <CesiumGltf/ExtensionModelExtFeatureMetadata.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

ExtensionModelExtFeatureMetadataJsonHandler::ExtensionModelExtFeatureMetadataJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _schema(context), _schemaUri(), _statistics(context), _featureTables(context), _featureTextures(context) {}

void ExtensionModelExtFeatureMetadataJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, ExtensionModelExtFeatureMetadata* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* ExtensionModelExtFeatureMetadataJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionModelExtFeatureMetadata(ExtensionModelExtFeatureMetadata::TypeName, str, *this->_pObject);
}

void ExtensionModelExtFeatureMetadataJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, CesiumUtility::ExtensibleObject& o, const std::string_view& extensionName) {
  std::any& value =
      o.extensions.emplace(extensionName, ExtensionModelExtFeatureMetadata())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<ExtensionModelExtFeatureMetadata&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionModelExtFeatureMetadataJsonHandler::readObjectKeyExtensionModelExtFeatureMetadata(const std::string& objectType, const std::string_view& str, ExtensionModelExtFeatureMetadata& o) {
  using namespace std::string_literals;

  if ("schema"s == str) return property("schema", this->_schema, o.schema);
  if ("schemaUri"s == str) return property("schemaUri", this->_schemaUri, o.schemaUri);
  if ("statistics"s == str) return property("statistics", this->_statistics, o.statistics);
  if ("featureTables"s == str) return property("featureTables", this->_featureTables, o.featureTables);
  if ("featureTextures"s == str) return property("featureTextures", this->_featureTextures, o.featureTextures);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler.h"
#include <CesiumGltf/ExtensionMeshPrimitiveExtFeatureMetadata.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler::ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _featureIdAttributes(context), _featureIdTextures(context), _featureTextures() {}

void ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, ExtensionMeshPrimitiveExtFeatureMetadata* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionMeshPrimitiveExtFeatureMetadata(ExtensionMeshPrimitiveExtFeatureMetadata::TypeName, str, *this->_pObject);
}

void ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, CesiumUtility::ExtensibleObject& o, const std::string_view& extensionName) {
  std::any& value =
      o.extensions.emplace(extensionName, ExtensionMeshPrimitiveExtFeatureMetadata())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<ExtensionMeshPrimitiveExtFeatureMetadata&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionMeshPrimitiveExtFeatureMetadataJsonHandler::readObjectKeyExtensionMeshPrimitiveExtFeatureMetadata(const std::string& objectType, const std::string_view& str, ExtensionMeshPrimitiveExtFeatureMetadata& o) {
  using namespace std::string_literals;

  if ("featureIdAttributes"s == str) return property("featureIdAttributes", this->_featureIdAttributes, o.featureIdAttributes);
  if ("featureIdTextures"s == str) return property("featureIdTextures", this->_featureIdTextures, o.featureIdTextures);
  if ("featureTextures"s == str) return property("featureTextures", this->_featureTextures, o.featureTextures);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "FeatureIDTextureJsonHandler.h"
#include <CesiumGltf/FeatureIDTexture.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

FeatureIDTextureJsonHandler::FeatureIDTextureJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _featureTable(), _featureIds(context) {}

void FeatureIDTextureJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, FeatureIDTexture* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* FeatureIDTextureJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyFeatureIDTexture(FeatureIDTexture::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* FeatureIDTextureJsonHandler::readObjectKeyFeatureIDTexture(const std::string& objectType, const std::string_view& str, FeatureIDTexture& o) {
  using namespace std::string_literals;

  if ("featureTable"s == str) return property("featureTable", this->_featureTable, o.featureTable);
  if ("featureIds"s == str) return property("featureIds", this->_featureIds, o.featureIds);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TextureAccessorJsonHandler.h"
#include <CesiumGltf/TextureAccessor.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

TextureAccessorJsonHandler::TextureAccessorJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _channels(), _texture(context) {}

void TextureAccessorJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, TextureAccessor* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* TextureAccessorJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTextureAccessor(TextureAccessor::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TextureAccessorJsonHandler::readObjectKeyTextureAccessor(const std::string& objectType, const std::string_view& str, TextureAccessor& o) {
  using namespace std::string_literals;

  if ("channels"s == str) return property("channels", this->_channels, o.channels);
  if ("texture"s == str) return property("texture", this->_texture, o.texture);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TextureInfoJsonHandler.h"
#include <CesiumGltf/TextureInfo.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

TextureInfoJsonHandler::TextureInfoJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _index(), _texCoord() {}

void TextureInfoJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, TextureInfo* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* TextureInfoJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTextureInfo(TextureInfo::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TextureInfoJsonHandler::readObjectKeyTextureInfo(const std::string& objectType, const std::string_view& str, TextureInfo& o) {
  using namespace std::string_literals;

  if ("index"s == str) return property("index", this->_index, o.index);
  if ("texCoord"s == str) return property("texCoord", this->_texCoord, o.texCoord);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "FeatureIDAttributeJsonHandler.h"
#include <CesiumGltf/FeatureIDAttribute.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

FeatureIDAttributeJsonHandler::FeatureIDAttributeJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _featureTable(), _featureIds(context) {}

void FeatureIDAttributeJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, FeatureIDAttribute* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* FeatureIDAttributeJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyFeatureIDAttribute(FeatureIDAttribute::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* FeatureIDAttributeJsonHandler::readObjectKeyFeatureIDAttribute(const std::string& objectType, const std::string_view& str, FeatureIDAttribute& o) {
  using namespace std::string_literals;

  if ("featureTable"s == str) return property("featureTable", this->_featureTable, o.featureTable);
  if ("featureIds"s == str) return property("featureIds", this->_featureIds, o.featureIds);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "FeatureIDsJsonHandler.h"
#include <CesiumGltf/FeatureIDs.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

FeatureIDsJsonHandler::FeatureIDsJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _attribute(), _constant(), _divisor() {}

void FeatureIDsJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, FeatureIDs* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* FeatureIDsJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyFeatureIDs(FeatureIDs::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* FeatureIDsJsonHandler::readObjectKeyFeatureIDs(const std::string& objectType, const std::string_view& str, FeatureIDs& o) {
  using namespace std::string_literals;

  if ("attribute"s == str) return property("attribute", this->_attribute, o.attribute);
  if ("constant"s == str) return property("constant", this->_constant, o.constant);
  if ("divisor"s == str) return property("divisor", this->_divisor, o.divisor);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "FeatureTextureJsonHandler.h"
#include <CesiumGltf/FeatureTexture.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

FeatureTextureJsonHandler::FeatureTextureJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _classProperty(), _properties(context) {}

void FeatureTextureJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, FeatureTexture* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* FeatureTextureJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyFeatureTexture(FeatureTexture::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* FeatureTextureJsonHandler::readObjectKeyFeatureTexture(const std::string& objectType, const std::string_view& str, FeatureTexture& o) {
  using namespace std::string_literals;

  if ("class"s == str) return property("class", this->_classProperty, o.classProperty);
  if ("properties"s == str) return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "FeatureTableJsonHandler.h"
#include <CesiumGltf/FeatureTable.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

FeatureTableJsonHandler::FeatureTableJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _classProperty(), _count(), _properties(context) {}

void FeatureTableJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, FeatureTable* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* FeatureTableJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyFeatureTable(FeatureTable::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* FeatureTableJsonHandler::readObjectKeyFeatureTable(const std::string& objectType, const std::string_view& str, FeatureTable& o) {
  using namespace std::string_literals;

  if ("class"s == str) return property("class", this->_classProperty, o.classProperty);
  if ("count"s == str) return property("count", this->_count, o.count);
  if ("properties"s == str) return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "FeatureTablePropertyJsonHandler.h"
#include <CesiumGltf/FeatureTableProperty.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

FeatureTablePropertyJsonHandler::FeatureTablePropertyJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _bufferView(), _offsetType(), _arrayOffsetBufferView(), _stringOffsetBufferView() {}

void FeatureTablePropertyJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, FeatureTableProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* FeatureTablePropertyJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyFeatureTableProperty(FeatureTableProperty::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* FeatureTablePropertyJsonHandler::readObjectKeyFeatureTableProperty(const std::string& objectType, const std::string_view& str, FeatureTableProperty& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str) return property("bufferView", this->_bufferView, o.bufferView);
  if ("offsetType"s == str) return property("offsetType", this->_offsetType, o.offsetType);
  if ("arrayOffsetBufferView"s == str) return property("arrayOffsetBufferView", this->_arrayOffsetBufferView, o.arrayOffsetBufferView);
  if ("stringOffsetBufferView"s == str) return property("stringOffsetBufferView", this->_stringOffsetBufferView, o.stringOffsetBufferView);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "StatisticsJsonHandler.h"
#include <CesiumGltf/Statistics.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

StatisticsJsonHandler::StatisticsJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _classes(context) {}

void StatisticsJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Statistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* StatisticsJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyStatistics(Statistics::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* StatisticsJsonHandler::readObjectKeyStatistics(const std::string& objectType, const std::string_view& str, Statistics& o) {
  using namespace std::string_literals;

  if ("classes"s == str) return property("classes", this->_classes, o.classes);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassStatisticsJsonHandler.h"
#include <CesiumGltf/ClassStatistics.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

ClassStatisticsJsonHandler::ClassStatisticsJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _count(), _properties(context) {}

void ClassStatisticsJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, ClassStatistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* ClassStatisticsJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyClassStatistics(ClassStatistics::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ClassStatisticsJsonHandler::readObjectKeyClassStatistics(const std::string& objectType, const std::string_view& str, ClassStatistics& o) {
  using namespace std::string_literals;

  if ("count"s == str) return property("count", this->_count, o.count);
  if ("properties"s == str) return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyStatisticsJsonHandler.h"
#include <CesiumGltf/PropertyStatistics.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

PropertyStatisticsJsonHandler::PropertyStatisticsJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _min(), _max(), _mean(), _median(), _standardDeviation(), _variance(), _sum(), _occurrences() {}

void PropertyStatisticsJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, PropertyStatistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* PropertyStatisticsJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyPropertyStatistics(PropertyStatistics::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* PropertyStatisticsJsonHandler::readObjectKeyPropertyStatistics(const std::string& objectType, const std::string_view& str, PropertyStatistics& o) {
  using namespace std::string_literals;

  if ("min"s == str) return property("min", this->_min, o.min);
  if ("max"s == str) return property("max", this->_max, o.max);
  if ("mean"s == str) return property("mean", this->_mean, o.mean);
  if ("median"s == str) return property("median", this->_median, o.median);
  if ("standardDeviation"s == str) return property("standardDeviation", this->_standardDeviation, o.standardDeviation);
  if ("variance"s == str) return property("variance", this->_variance, o.variance);
  if ("sum"s == str) return property("sum", this->_sum, o.sum);
  if ("occurrences"s == str) return property("occurrences", this->_occurrences, o.occurrences);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SchemaJsonHandler.h"
#include <CesiumGltf/Schema.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

SchemaJsonHandler::SchemaJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _name(), _description(), _version(), _classes(context), _enums(context) {}

void SchemaJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Schema* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* SchemaJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySchema(Schema::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SchemaJsonHandler::readObjectKeySchema(const std::string& objectType, const std::string_view& str, Schema& o) {
  using namespace std::string_literals;

  if ("name"s == str) return property("name", this->_name, o.name);
  if ("description"s == str) return property("description", this->_description, o.description);
  if ("version"s == str) return property("version", this->_version, o.version);
  if ("classes"s == str) return property("classes", this->_classes, o.classes);
  if ("enums"s == str) return property("enums", this->_enums, o.enums);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "EnumJsonHandler.h"
#include <CesiumGltf/Enum.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

EnumJsonHandler::EnumJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _name(), _description(), _valueType(), _values(context) {}

void EnumJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Enum* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* EnumJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyEnum(Enum::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* EnumJsonHandler::readObjectKeyEnum(const std::string& objectType, const std::string_view& str, Enum& o) {
  using namespace std::string_literals;

  if ("name"s == str) return property("name", this->_name, o.name);
  if ("description"s == str) return property("description", this->_description, o.description);
  if ("valueType"s == str) return property("valueType", this->_valueType, o.valueType);
  if ("values"s == str) return property("values", this->_values, o.values);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "EnumValueJsonHandler.h"
#include <CesiumGltf/EnumValue.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

EnumValueJsonHandler::EnumValueJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _name(), _description(), _value() {}

void EnumValueJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, EnumValue* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* EnumValueJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyEnumValue(EnumValue::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* EnumValueJsonHandler::readObjectKeyEnumValue(const std::string& objectType, const std::string_view& str, EnumValue& o) {
  using namespace std::string_literals;

  if ("name"s == str) return property("name", this->_name, o.name);
  if ("description"s == str) return property("description", this->_description, o.description);
  if ("value"s == str) return property("value", this->_value, o.value);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassJsonHandler.h"
#include <CesiumGltf/Class.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

ClassJsonHandler::ClassJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _name(), _description(), _properties(context) {}

void ClassJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Class* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* ClassJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyClass(Class::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ClassJsonHandler::readObjectKeyClass(const std::string& objectType, const std::string_view& str, Class& o) {
  using namespace std::string_literals;

  if ("name"s == str) return property("name", this->_name, o.name);
  if ("description"s == str) return property("description", this->_description, o.description);
  if ("properties"s == str) return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassPropertyJsonHandler.h"
#include <CesiumGltf/ClassProperty.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

ClassPropertyJsonHandler::ClassPropertyJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _name(), _description(), _type(), _enumType(), _componentType(), _componentCount(), _normalized(), _max(), _min(), _defaultProperty(), _optional(), _semantic() {}

void ClassPropertyJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, ClassProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* ClassPropertyJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyClassProperty(ClassProperty::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ClassPropertyJsonHandler::readObjectKeyClassProperty(const std::string& objectType, const std::string_view& str, ClassProperty& o) {
  using namespace std::string_literals;

  if ("name"s == str) return property("name", this->_name, o.name);
  if ("description"s == str) return property("description", this->_description, o.description);
  if ("type"s == str) return property("type", this->_type, o.type);
  if ("enumType"s == str) return property("enumType", this->_enumType, o.enumType);
  if ("componentType"s == str) return property("componentType", this->_componentType, o.componentType);
  if ("componentCount"s == str) return property("componentCount", this->_componentCount, o.componentCount);
  if ("normalized"s == str) return property("normalized", this->_normalized, o.normalized);
  if ("max"s == str) return property("max", this->_max, o.max);
  if ("min"s == str) return property("min", this->_min, o.min);
  if ("default"s == str) return property("default", this->_defaultProperty, o.defaultProperty);
  if ("optional"s == str) return property("optional", this->_optional, o.optional);
  if ("semantic"s == str) return property("semantic", this->_semantic, o.semantic);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ModelJsonHandler.h"
#include <CesiumGltf/Model.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

ModelJsonHandler::ModelJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _extensionsUsed(), _extensionsRequired(), _accessors(context), _animations(context), _asset(context), _buffers(context), _bufferViews(context), _cameras(context), _images(context), _materials(context), _meshes(context), _nodes(context), _samplers(context), _scene(), _scenes(context), _skins(context), _textures(context) {}

void ModelJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Model* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* ModelJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyModel(Model::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ModelJsonHandler::readObjectKeyModel(const std::string& objectType, const std::string_view& str, Model& o) {
  using namespace std::string_literals;

  if ("extensionsUsed"s == str) return property("extensionsUsed", this->_extensionsUsed, o.extensionsUsed);
  if ("extensionsRequired"s == str) return property("extensionsRequired", this->_extensionsRequired, o.extensionsRequired);
  if ("accessors"s == str) return property("accessors", this->_accessors, o.accessors);
  if ("animations"s == str) return property("animations", this->_animations, o.animations);
  if ("asset"s == str) return property("asset", this->_asset, o.asset);
  if ("buffers"s == str) return property("buffers", this->_buffers, o.buffers);
  if ("bufferViews"s == str) return property("bufferViews", this->_bufferViews, o.bufferViews);
  if ("cameras"s == str) return property("cameras", this->_cameras, o.cameras);
  if ("images"s == str) return property("images", this->_images, o.images);
  if ("materials"s == str) return property("materials", this->_materials, o.materials);
  if ("meshes"s == str) return property("meshes", this->_meshes, o.meshes);
  if ("nodes"s == str) return property("nodes", this->_nodes, o.nodes);
  if ("samplers"s == str) return property("samplers", this->_samplers, o.samplers);
  if ("scene"s == str) return property("scene", this->_scene, o.scene);
  if ("scenes"s == str) return property("scenes", this->_scenes, o.scenes);
  if ("skins"s == str) return property("skins", this->_skins, o.skins);
  if ("textures"s == str) return property("textures", this->_textures, o.textures);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TextureJsonHandler.h"
#include <CesiumGltf/Texture.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

TextureJsonHandler::TextureJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : NamedObjectJsonHandler(context), _sampler(), _source() {}

void TextureJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Texture* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* TextureJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTexture(Texture::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TextureJsonHandler::readObjectKeyTexture(const std::string& objectType, const std::string_view& str, Texture& o) {
  using namespace std::string_literals;

  if ("sampler"s == str) return property("sampler", this->_sampler, o.sampler);
  if ("source"s == str) return property("source", this->_source, o.source);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SkinJsonHandler.h"
#include <CesiumGltf/Skin.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

SkinJsonHandler::SkinJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : NamedObjectJsonHandler(context), _inverseBindMatrices(), _skeleton(), _joints() {}

void SkinJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Skin* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* SkinJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySkin(Skin::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SkinJsonHandler::readObjectKeySkin(const std::string& objectType, const std::string_view& str, Skin& o) {
  using namespace std::string_literals;

  if ("inverseBindMatrices"s == str) return property("inverseBindMatrices", this->_inverseBindMatrices, o.inverseBindMatrices);
  if ("skeleton"s == str) return property("skeleton", this->_skeleton, o.skeleton);
  if ("joints"s == str) return property("joints", this->_joints, o.joints);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SceneJsonHandler.h"
#include <CesiumGltf/Scene.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

SceneJsonHandler::SceneJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : NamedObjectJsonHandler(context), _nodes() {}

void SceneJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Scene* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* SceneJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyScene(Scene::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SceneJsonHandler::readObjectKeyScene(const std::string& objectType, const std::string_view& str, Scene& o) {
  using namespace std::string_literals;

  if ("nodes"s == str) return property("nodes", this->_nodes, o.nodes);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SamplerJsonHandler.h"
#include <CesiumGltf/Sampler.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

SamplerJsonHandler::SamplerJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : NamedObjectJsonHandler(context), _magFilter(), _minFilter(), _wrapS(), _wrapT() {}

void SamplerJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Sampler* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* SamplerJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySampler(Sampler::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SamplerJsonHandler::readObjectKeySampler(const std::string& objectType, const std::string_view& str, Sampler& o) {
  using namespace std::string_literals;

  if ("magFilter"s == str) return property("magFilter", this->_magFilter, o.magFilter);
  if ("minFilter"s == str) return property("minFilter", this->_minFilter, o.minFilter);
  if ("wrapS"s == str) return property("wrapS", this->_wrapS, o.wrapS);
  if ("wrapT"s == str) return property("wrapT", this->_wrapT, o.wrapT);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "NodeJsonHandler.h"
#include <CesiumGltf/Node.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

NodeJsonHandler::NodeJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : NamedObjectJsonHandler(context), _camera(), _children(), _skin(), _matrix(), _mesh(), _rotation(), _scale(), _translation(), _weights() {}

void NodeJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Node* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* NodeJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyNode(Node::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* NodeJsonHandler::readObjectKeyNode(const std::string& objectType, const std::string_view& str, Node& o) {
  using namespace std::string_literals;

  if ("camera"s == str) return property("camera", this->_camera, o.camera);
  if ("children"s == str) return property("children", this->_children, o.children);
  if ("skin"s == str) return property("skin", this->_skin, o.skin);
  if ("matrix"s == str) return property("matrix", this->_matrix, o.matrix);
  if ("mesh"s == str) return property("mesh", this->_mesh, o.mesh);
  if ("rotation"s == str) return property("rotation", this->_rotation, o.rotation);
  if ("scale"s == str) return property("scale", this->_scale, o.scale);
  if ("translation"s == str) return property("translation", this->_translation, o.translation);
  if ("weights"s == str) return property("weights", this->_weights, o.weights);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MeshJsonHandler.h"
#include <CesiumGltf/Mesh.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

MeshJsonHandler::MeshJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : NamedObjectJsonHandler(context), _primitives(context), _weights() {}

void MeshJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Mesh* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* MeshJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMesh(Mesh::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MeshJsonHandler::readObjectKeyMesh(const std::string& objectType, const std::string_view& str, Mesh& o) {
  using namespace std::string_literals;

  if ("primitives"s == str) return property("primitives", this->_primitives, o.primitives);
  if ("weights"s == str) return property("weights", this->_weights, o.weights);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MeshPrimitiveJsonHandler.h"
#include <CesiumGltf/MeshPrimitive.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

MeshPrimitiveJsonHandler::MeshPrimitiveJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _attributes(), _indices(), _material(), _mode(), _targets() {}

void MeshPrimitiveJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, MeshPrimitive* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* MeshPrimitiveJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMeshPrimitive(MeshPrimitive::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MeshPrimitiveJsonHandler::readObjectKeyMeshPrimitive(const std::string& objectType, const std::string_view& str, MeshPrimitive& o) {
  using namespace std::string_literals;

  if ("attributes"s == str) return property("attributes", this->_attributes, o.attributes);
  if ("indices"s == str) return property("indices", this->_indices, o.indices);
  if ("material"s == str) return property("material", this->_material, o.material);
  if ("mode"s == str) return property("mode", this->_mode, o.mode);
  if ("targets"s == str) return property("targets", this->_targets, o.targets);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MaterialJsonHandler.h"
#include <CesiumGltf/Material.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

MaterialJsonHandler::MaterialJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : NamedObjectJsonHandler(context), _pbrMetallicRoughness(context), _normalTexture(context), _occlusionTexture(context), _emissiveTexture(context), _emissiveFactor(), _alphaMode(), _alphaCutoff(), _doubleSided() {}

void MaterialJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Material* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* MaterialJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterial(Material::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MaterialJsonHandler::readObjectKeyMaterial(const std::string& objectType, const std::string_view& str, Material& o) {
  using namespace std::string_literals;

  if ("pbrMetallicRoughness"s == str) return property("pbrMetallicRoughness", this->_pbrMetallicRoughness, o.pbrMetallicRoughness);
  if ("normalTexture"s == str) return property("normalTexture", this->_normalTexture, o.normalTexture);
  if ("occlusionTexture"s == str) return property("occlusionTexture", this->_occlusionTexture, o.occlusionTexture);
  if ("emissiveTexture"s == str) return property("emissiveTexture", this->_emissiveTexture, o.emissiveTexture);
  if ("emissiveFactor"s == str) return property("emissiveFactor", this->_emissiveFactor, o.emissiveFactor);
  if ("alphaMode"s == str) return property("alphaMode", this->_alphaMode, o.alphaMode);
  if ("alphaCutoff"s == str) return property("alphaCutoff", this->_alphaCutoff, o.alphaCutoff);
  if ("doubleSided"s == str) return property("doubleSided", this->_doubleSided, o.doubleSided);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MaterialOcclusionTextureInfoJsonHandler.h"
#include <CesiumGltf/MaterialOcclusionTextureInfo.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

MaterialOcclusionTextureInfoJsonHandler::MaterialOcclusionTextureInfoJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : TextureInfoJsonHandler(context), _strength() {}

void MaterialOcclusionTextureInfoJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, MaterialOcclusionTextureInfo* pObject) {
  TextureInfoJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* MaterialOcclusionTextureInfoJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterialOcclusionTextureInfo(MaterialOcclusionTextureInfo::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MaterialOcclusionTextureInfoJsonHandler::readObjectKeyMaterialOcclusionTextureInfo(const std::string& objectType, const std::string_view& str, MaterialOcclusionTextureInfo& o) {
  using namespace std::string_literals;

  if ("strength"s == str) return property("strength", this->_strength, o.strength);

  return this->readObjectKeyTextureInfo(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MaterialNormalTextureInfoJsonHandler.h"
#include <CesiumGltf/MaterialNormalTextureInfo.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

MaterialNormalTextureInfoJsonHandler::MaterialNormalTextureInfoJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : TextureInfoJsonHandler(context), _scale() {}

void MaterialNormalTextureInfoJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, MaterialNormalTextureInfo* pObject) {
  TextureInfoJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* MaterialNormalTextureInfoJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterialNormalTextureInfo(MaterialNormalTextureInfo::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MaterialNormalTextureInfoJsonHandler::readObjectKeyMaterialNormalTextureInfo(const std::string& objectType, const std::string_view& str, MaterialNormalTextureInfo& o) {
  using namespace std::string_literals;

  if ("scale"s == str) return property("scale", this->_scale, o.scale);

  return this->readObjectKeyTextureInfo(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MaterialPBRMetallicRoughnessJsonHandler.h"
#include <CesiumGltf/MaterialPBRMetallicRoughness.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

MaterialPBRMetallicRoughnessJsonHandler::MaterialPBRMetallicRoughnessJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _baseColorFactor(), _baseColorTexture(context), _metallicFactor(), _roughnessFactor(), _metallicRoughnessTexture(context) {}

void MaterialPBRMetallicRoughnessJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, MaterialPBRMetallicRoughness* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* MaterialPBRMetallicRoughnessJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMaterialPBRMetallicRoughness(MaterialPBRMetallicRoughness::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* MaterialPBRMetallicRoughnessJsonHandler::readObjectKeyMaterialPBRMetallicRoughness(const std::string& objectType, const std::string_view& str, MaterialPBRMetallicRoughness& o) {
  using namespace std::string_literals;

  if ("baseColorFactor"s == str) return property("baseColorFactor", this->_baseColorFactor, o.baseColorFactor);
  if ("baseColorTexture"s == str) return property("baseColorTexture", this->_baseColorTexture, o.baseColorTexture);
  if ("metallicFactor"s == str) return property("metallicFactor", this->_metallicFactor, o.metallicFactor);
  if ("roughnessFactor"s == str) return property("roughnessFactor", this->_roughnessFactor, o.roughnessFactor);
  if ("metallicRoughnessTexture"s == str) return property("metallicRoughnessTexture", this->_metallicRoughnessTexture, o.metallicRoughnessTexture);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ImageJsonHandler.h"
#include <CesiumGltf/Image.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

ImageJsonHandler::ImageJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : NamedObjectJsonHandler(context), _uri(), _mimeType(), _bufferView() {}

void ImageJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Image* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* ImageJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyImage(Image::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ImageJsonHandler::readObjectKeyImage(const std::string& objectType, const std::string_view& str, Image& o) {
  using namespace std::string_literals;

  if ("uri"s == str) return property("uri", this->_uri, o.uri);
  if ("mimeType"s == str) return property("mimeType", this->_mimeType, o.mimeType);
  if ("bufferView"s == str) return property("bufferView", this->_bufferView, o.bufferView);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "CameraJsonHandler.h"
#include <CesiumGltf/Camera.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

CameraJsonHandler::CameraJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : NamedObjectJsonHandler(context), _orthographic(context), _perspective(context), _type() {}

void CameraJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Camera* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* CameraJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyCamera(Camera::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* CameraJsonHandler::readObjectKeyCamera(const std::string& objectType, const std::string_view& str, Camera& o) {
  using namespace std::string_literals;

  if ("orthographic"s == str) return property("orthographic", this->_orthographic, o.orthographic);
  if ("perspective"s == str) return property("perspective", this->_perspective, o.perspective);
  if ("type"s == str) return property("type", this->_type, o.type);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "CameraPerspectiveJsonHandler.h"
#include <CesiumGltf/CameraPerspective.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

CameraPerspectiveJsonHandler::CameraPerspectiveJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _aspectRatio(), _yfov(), _zfar(), _znear() {}

void CameraPerspectiveJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, CameraPerspective* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* CameraPerspectiveJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyCameraPerspective(CameraPerspective::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* CameraPerspectiveJsonHandler::readObjectKeyCameraPerspective(const std::string& objectType, const std::string_view& str, CameraPerspective& o) {
  using namespace std::string_literals;

  if ("aspectRatio"s == str) return property("aspectRatio", this->_aspectRatio, o.aspectRatio);
  if ("yfov"s == str) return property("yfov", this->_yfov, o.yfov);
  if ("zfar"s == str) return property("zfar", this->_zfar, o.zfar);
  if ("znear"s == str) return property("znear", this->_znear, o.znear);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "CameraOrthographicJsonHandler.h"
#include <CesiumGltf/CameraOrthographic.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

CameraOrthographicJsonHandler::CameraOrthographicJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _xmag(), _ymag(), _zfar(), _znear() {}

void CameraOrthographicJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, CameraOrthographic* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* CameraOrthographicJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyCameraOrthographic(CameraOrthographic::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* CameraOrthographicJsonHandler::readObjectKeyCameraOrthographic(const std::string& objectType, const std::string_view& str, CameraOrthographic& o) {
  using namespace std::string_literals;

  if ("xmag"s == str) return property("xmag", this->_xmag, o.xmag);
  if ("ymag"s == str) return property("ymag", this->_ymag, o.ymag);
  if ("zfar"s == str) return property("zfar", this->_zfar, o.zfar);
  if ("znear"s == str) return property("znear", this->_znear, o.znear);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferViewJsonHandler.h"
#include <CesiumGltf/BufferView.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

BufferViewJsonHandler::BufferViewJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : NamedObjectJsonHandler(context), _buffer(), _byteOffset(), _byteLength(), _byteStride(), _target() {}

void BufferViewJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, BufferView* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* BufferViewJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBufferView(BufferView::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferViewJsonHandler::readObjectKeyBufferView(const std::string& objectType, const std::string_view& str, BufferView& o) {
  using namespace std::string_literals;

  if ("buffer"s == str) return property("buffer", this->_buffer, o.buffer);
  if ("byteOffset"s == str) return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("byteLength"s == str) return property("byteLength", this->_byteLength, o.byteLength);
  if ("byteStride"s == str) return property("byteStride", this->_byteStride, o.byteStride);
  if ("target"s == str) return property("target", this->_target, o.target);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferJsonHandler.h"
#include <CesiumGltf/Buffer.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

BufferJsonHandler::BufferJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : NamedObjectJsonHandler(context), _uri(), _byteLength() {}

void BufferJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Buffer* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* BufferJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBuffer(Buffer::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferJsonHandler::readObjectKeyBuffer(const std::string& objectType, const std::string_view& str, Buffer& o) {
  using namespace std::string_literals;

  if ("uri"s == str) return property("uri", this->_uri, o.uri);
  if ("byteLength"s == str) return property("byteLength", this->_byteLength, o.byteLength);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AssetJsonHandler.h"
#include <CesiumGltf/Asset.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

AssetJsonHandler::AssetJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _copyright(), _generator(), _version(), _minVersion() {}

void AssetJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Asset* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* AssetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAsset(Asset::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AssetJsonHandler::readObjectKeyAsset(const std::string& objectType, const std::string_view& str, Asset& o) {
  using namespace std::string_literals;

  if ("copyright"s == str) return property("copyright", this->_copyright, o.copyright);
  if ("generator"s == str) return property("generator", this->_generator, o.generator);
  if ("version"s == str) return property("version", this->_version, o.version);
  if ("minVersion"s == str) return property("minVersion", this->_minVersion, o.minVersion);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationJsonHandler.h"
#include <CesiumGltf/Animation.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

AnimationJsonHandler::AnimationJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : NamedObjectJsonHandler(context), _channels(context), _samplers(context) {}

void AnimationJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Animation* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* AnimationJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimation(Animation::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AnimationJsonHandler::readObjectKeyAnimation(const std::string& objectType, const std::string_view& str, Animation& o) {
  using namespace std::string_literals;

  if ("channels"s == str) return property("channels", this->_channels, o.channels);
  if ("samplers"s == str) return property("samplers", this->_samplers, o.samplers);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationSamplerJsonHandler.h"
#include <CesiumGltf/AnimationSampler.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

AnimationSamplerJsonHandler::AnimationSamplerJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _input(), _interpolation(), _output() {}

void AnimationSamplerJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, AnimationSampler* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* AnimationSamplerJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimationSampler(AnimationSampler::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AnimationSamplerJsonHandler::readObjectKeyAnimationSampler(const std::string& objectType, const std::string_view& str, AnimationSampler& o) {
  using namespace std::string_literals;

  if ("input"s == str) return property("input", this->_input, o.input);
  if ("interpolation"s == str) return property("interpolation", this->_interpolation, o.interpolation);
  if ("output"s == str) return property("output", this->_output, o.output);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationChannelJsonHandler.h"
#include <CesiumGltf/AnimationChannel.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

AnimationChannelJsonHandler::AnimationChannelJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _sampler(), _target(context) {}

void AnimationChannelJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, AnimationChannel* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* AnimationChannelJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimationChannel(AnimationChannel::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AnimationChannelJsonHandler::readObjectKeyAnimationChannel(const std::string& objectType, const std::string_view& str, AnimationChannel& o) {
  using namespace std::string_literals;

  if ("sampler"s == str) return property("sampler", this->_sampler, o.sampler);
  if ("target"s == str) return property("target", this->_target, o.target);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AnimationChannelTargetJsonHandler.h"
#include <CesiumGltf/AnimationChannelTarget.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

AnimationChannelTargetJsonHandler::AnimationChannelTargetJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _node(), _path() {}

void AnimationChannelTargetJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, AnimationChannelTarget* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* AnimationChannelTargetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAnimationChannelTarget(AnimationChannelTarget::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AnimationChannelTargetJsonHandler::readObjectKeyAnimationChannelTarget(const std::string& objectType, const std::string_view& str, AnimationChannelTarget& o) {
  using namespace std::string_literals;

  if ("node"s == str) return property("node", this->_node, o.node);
  if ("path"s == str) return property("path", this->_path, o.path);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorJsonHandler.h"
#include <CesiumGltf/Accessor.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

AccessorJsonHandler::AccessorJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : NamedObjectJsonHandler(context), _bufferView(), _byteOffset(), _componentType(), _normalized(), _count(), _type(), _max(), _min(), _sparse(context) {}

void AccessorJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, Accessor* pObject) {
  NamedObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* AccessorJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessor(Accessor::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AccessorJsonHandler::readObjectKeyAccessor(const std::string& objectType, const std::string_view& str, Accessor& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str) return property("bufferView", this->_bufferView, o.bufferView);
  if ("byteOffset"s == str) return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("componentType"s == str) return property("componentType", this->_componentType, o.componentType);
  if ("normalized"s == str) return property("normalized", this->_normalized, o.normalized);
  if ("count"s == str) return property("count", this->_count, o.count);
  if ("type"s == str) return property("type", this->_type, o.type);
  if ("max"s == str) return property("max", this->_max, o.max);
  if ("min"s == str) return property("min", this->_min, o.min);
  if ("sparse"s == str) return property("sparse", this->_sparse, o.sparse);

  return this->readObjectKeyNamedObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorSparseJsonHandler.h"
#include <CesiumGltf/AccessorSparse.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

AccessorSparseJsonHandler::AccessorSparseJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _count(), _indices(context), _values(context) {}

void AccessorSparseJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, AccessorSparse* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* AccessorSparseJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessorSparse(AccessorSparse::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AccessorSparseJsonHandler::readObjectKeyAccessorSparse(const std::string& objectType, const std::string_view& str, AccessorSparse& o) {
  using namespace std::string_literals;

  if ("count"s == str) return property("count", this->_count, o.count);
  if ("indices"s == str) return property("indices", this->_indices, o.indices);
  if ("values"s == str) return property("values", this->_values, o.values);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorSparseValuesJsonHandler.h"
#include <CesiumGltf/AccessorSparseValues.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

AccessorSparseValuesJsonHandler::AccessorSparseValuesJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _bufferView(), _byteOffset() {}

void AccessorSparseValuesJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, AccessorSparseValues* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* AccessorSparseValuesJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessorSparseValues(AccessorSparseValues::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AccessorSparseValuesJsonHandler::readObjectKeyAccessorSparseValues(const std::string& objectType, const std::string_view& str, AccessorSparseValues& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str) return property("bufferView", this->_bufferView, o.bufferView);
  if ("byteOffset"s == str) return property("byteOffset", this->_byteOffset, o.byteOffset);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AccessorSparseIndicesJsonHandler.h"
#include <CesiumGltf/AccessorSparseIndices.h>

#include <cassert>
#include <string>

using namespace CesiumGltf;

AccessorSparseIndicesJsonHandler::AccessorSparseIndicesJsonHandler(const CesiumJsonReader::ExtensionReaderContext& context) noexcept : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _bufferView(), _byteOffset(), _componentType() {}

void AccessorSparseIndicesJsonHandler::reset(CesiumJsonReader::IJsonHandler* pParentHandler, AccessorSparseIndices* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler* AccessorSparseIndicesJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAccessorSparseIndices(AccessorSparseIndices::TypeName, str, *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AccessorSparseIndicesJsonHandler::readObjectKeyAccessorSparseIndices(const std::string& objectType, const std::string_view& str, AccessorSparseIndices& o) {
  using namespace std::string_literals;

  if ("bufferView"s == str) return property("bufferView", this->_bufferView, o.bufferView);
  if ("byteOffset"s == str) return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("componentType"s == str) return property("componentType", this->_componentType, o.componentType);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}
