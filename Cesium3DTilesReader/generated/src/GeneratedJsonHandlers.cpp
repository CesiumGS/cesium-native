// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesBoundingVolumeS2JsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/Extension3dTilesBoundingVolumeS2.h>
#include <Cesium3DTilesReader/Extension3dTilesBoundingVolumeS2Reader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesBoundingVolumeS2JsonHandler::
    Extension3dTilesBoundingVolumeS2JsonHandler(
        const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _token(),
      _minimumHeight(),
      _maximumHeight() {}

void Extension3dTilesBoundingVolumeS2JsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesBoundingVolumeS2* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesBoundingVolumeS2JsonHandler::readObjectKey(
    const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyExtension3dTilesBoundingVolumeS2(
      Cesium3DTiles::Extension3dTilesBoundingVolumeS2::TypeName,
      str,
      *this->_pObject);
}

void Extension3dTilesBoundingVolumeS2JsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            Cesium3DTiles::Extension3dTilesBoundingVolumeS2())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::Extension3dTilesBoundingVolumeS2&>(value));
}

CesiumJsonReader::IJsonHandler* Extension3dTilesBoundingVolumeS2JsonHandler::
    readObjectKeyExtension3dTilesBoundingVolumeS2(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesBoundingVolumeS2& o) {
  using namespace std::string_literals;

  if ("token"s == str)
    return property("token", this->_token, o.token);
  if ("minimumHeight"s == str)
    return property("minimumHeight", this->_minimumHeight, o.minimumHeight);
  if ("maximumHeight"s == str)
    return property("maximumHeight", this->_maximumHeight, o.maximumHeight);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

Extension3dTilesBoundingVolumeS2Reader::
    Extension3dTilesBoundingVolumeS2Reader() {
  registerReaderExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions&
Extension3dTilesBoundingVolumeS2Reader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
Extension3dTilesBoundingVolumeS2Reader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<
    Cesium3DTiles::Extension3dTilesBoundingVolumeS2>
Extension3dTilesBoundingVolumeS2Reader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  Extension3dTilesBoundingVolumeS2JsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<
    Cesium3DTiles::Extension3dTilesBoundingVolumeS2>
Extension3dTilesBoundingVolumeS2Reader::readFromJson(
    const rapidjson::Value& value) const {
  Extension3dTilesBoundingVolumeS2JsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<Cesium3DTiles::Extension3dTilesBoundingVolumeS2>>
Extension3dTilesBoundingVolumeS2Reader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      Cesium3DTiles::Extension3dTilesBoundingVolumeS2,
      Extension3dTilesBoundingVolumeS2JsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "StatisticsJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/Statistics.h>
#include <Cesium3DTilesReader/StatisticsReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

StatisticsJsonHandler::StatisticsJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _classes(options) {}

void StatisticsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Statistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
StatisticsJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyStatistics(
      Cesium3DTiles::Statistics::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* StatisticsJsonHandler::readObjectKeyStatistics(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Statistics& o) {
  using namespace std::string_literals;

  if ("classes"s == str)
    return property("classes", this->_classes, o.classes);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

StatisticsReader::StatisticsReader() {
  registerReaderExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& StatisticsReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
StatisticsReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Statistics>
StatisticsReader::readFromJson(const gsl::span<const std::byte>& data) const {
  StatisticsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Statistics>
StatisticsReader::readFromJson(const rapidjson::Value& value) const {
  StatisticsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::Statistics>>
StatisticsReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<Cesium3DTiles::Statistics, StatisticsJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassStatisticsJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/ClassStatistics.h>
#include <Cesium3DTilesReader/ClassStatisticsReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

ClassStatisticsJsonHandler::ClassStatisticsJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _count(),
      _properties(options) {}

void ClassStatisticsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::ClassStatistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ClassStatisticsJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyClassStatistics(
      Cesium3DTiles::ClassStatistics::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ClassStatisticsJsonHandler::readObjectKeyClassStatistics(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::ClassStatistics& o) {
  using namespace std::string_literals;

  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ClassStatisticsReader::ClassStatisticsReader() {
  registerReaderExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& ClassStatisticsReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ClassStatisticsReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::ClassStatistics>
ClassStatisticsReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ClassStatisticsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::ClassStatistics>
ClassStatisticsReader::readFromJson(const rapidjson::Value& value) const {
  ClassStatisticsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::ClassStatistics>>
ClassStatisticsReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      Cesium3DTiles::ClassStatistics,
      ClassStatisticsJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyStatisticsJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/PropertyStatistics.h>
#include <Cesium3DTilesReader/PropertyStatisticsReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

PropertyStatisticsJsonHandler::PropertyStatisticsJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _min(),
      _max(),
      _mean(),
      _median(),
      _standardDeviation(),
      _variance(),
      _sum(),
      _occurrences() {}

void PropertyStatisticsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::PropertyStatistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyStatisticsJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyPropertyStatistics(
      Cesium3DTiles::PropertyStatistics::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyStatisticsJsonHandler::readObjectKeyPropertyStatistics(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::PropertyStatistics& o) {
  using namespace std::string_literals;

  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("mean"s == str)
    return property("mean", this->_mean, o.mean);
  if ("median"s == str)
    return property("median", this->_median, o.median);
  if ("standardDeviation"s == str)
    return property(
        "standardDeviation",
        this->_standardDeviation,
        o.standardDeviation);
  if ("variance"s == str)
    return property("variance", this->_variance, o.variance);
  if ("sum"s == str)
    return property("sum", this->_sum, o.sum);
  if ("occurrences"s == str)
    return property("occurrences", this->_occurrences, o.occurrences);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

PropertyStatisticsReader::PropertyStatisticsReader() {
  registerReaderExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& PropertyStatisticsReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
PropertyStatisticsReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::PropertyStatistics>
PropertyStatisticsReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  PropertyStatisticsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::PropertyStatistics>
PropertyStatisticsReader::readFromJson(const rapidjson::Value& value) const {
  PropertyStatisticsJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::PropertyStatistics>>
PropertyStatisticsReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      Cesium3DTiles::PropertyStatistics,
      PropertyStatisticsJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SchemaJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/Schema.h>
#include <Cesium3DTilesReader/SchemaReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

SchemaJsonHandler::SchemaJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _id(),
      _name(),
      _description(),
      _version(),
      _classes(options),
      _enums(options) {}

void SchemaJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Schema* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SchemaJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeySchema(
      Cesium3DTiles::Schema::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SchemaJsonHandler::readObjectKeySchema(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Schema& o) {
  using namespace std::string_literals;

  if ("id"s == str)
    return property("id", this->_id, o.id);
  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("classes"s == str)
    return property("classes", this->_classes, o.classes);
  if ("enums"s == str)
    return property("enums", this->_enums, o.enums);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

SchemaReader::SchemaReader() { registerReaderExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& SchemaReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& SchemaReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Schema>
SchemaReader::readFromJson(const gsl::span<const std::byte>& data) const {
  SchemaJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Schema>
SchemaReader::readFromJson(const rapidjson::Value& value) const {
  SchemaJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::Schema>>
SchemaReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<Cesium3DTiles::Schema, SchemaJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "EnumJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/Enum.h>
#include <Cesium3DTilesReader/EnumReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

EnumJsonHandler::EnumJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _description(),
      _valueType(),
      _values(options) {}

void EnumJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Enum* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
EnumJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyEnum(
      Cesium3DTiles::Enum::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* EnumJsonHandler::readObjectKeyEnum(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Enum& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("valueType"s == str)
    return property("valueType", this->_valueType, o.valueType);
  if ("values"s == str)
    return property("values", this->_values, o.values);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

EnumReader::EnumReader() { registerReaderExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& EnumReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& EnumReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Enum>
EnumReader::readFromJson(const gsl::span<const std::byte>& data) const {
  EnumJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Enum>
EnumReader::readFromJson(const rapidjson::Value& value) const {
  EnumJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::Enum>>
EnumReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<Cesium3DTiles::Enum, EnumJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "EnumValueJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/EnumValue.h>
#include <Cesium3DTilesReader/EnumValueReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

EnumValueJsonHandler::EnumValueJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _description(),
      _value() {}

void EnumValueJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::EnumValue* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
EnumValueJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyEnumValue(
      Cesium3DTiles::EnumValue::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* EnumValueJsonHandler::readObjectKeyEnumValue(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::EnumValue& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("value"s == str)
    return property("value", this->_value, o.value);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

EnumValueReader::EnumValueReader() { registerReaderExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& EnumValueReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& EnumValueReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::EnumValue>
EnumValueReader::readFromJson(const gsl::span<const std::byte>& data) const {
  EnumValueJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::EnumValue>
EnumValueReader::readFromJson(const rapidjson::Value& value) const {
  EnumValueJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::EnumValue>>
EnumValueReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<Cesium3DTiles::EnumValue, EnumValueJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/Class.h>
#include <Cesium3DTilesReader/ClassReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

ClassJsonHandler::ClassJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _description(),
      _properties(options) {}

void ClassJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Class* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ClassJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyClass(
      Cesium3DTiles::Class::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ClassJsonHandler::readObjectKeyClass(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Class& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ClassReader::ClassReader() { registerReaderExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& ClassReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& ClassReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Class>
ClassReader::readFromJson(const gsl::span<const std::byte>& data) const {
  ClassJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Class>
ClassReader::readFromJson(const rapidjson::Value& value) const {
  ClassJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::Class>>
ClassReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<Cesium3DTiles::Class, ClassJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassPropertyJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/ClassProperty.h>
#include <Cesium3DTilesReader/ClassPropertyReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

ClassPropertyJsonHandler::ClassPropertyJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _description(),
      _type(),
      _componentType(),
      _enumType(),
      _array(),
      _count(),
      _normalized(),
      _offset(),
      _scale(),
      _max(),
      _min(),
      _required(),
      _noData(),
      _defaultProperty(),
      _semantic() {}

void ClassPropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::ClassProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ClassPropertyJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyClassProperty(
      Cesium3DTiles::ClassProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ClassPropertyJsonHandler::readObjectKeyClassProperty(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::ClassProperty& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("type"s == str)
    return property("type", this->_type, o.type);
  if ("componentType"s == str)
    return property("componentType", this->_componentType, o.componentType);
  if ("enumType"s == str)
    return property("enumType", this->_enumType, o.enumType);
  if ("array"s == str)
    return property("array", this->_array, o.array);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("normalized"s == str)
    return property("normalized", this->_normalized, o.normalized);
  if ("offset"s == str)
    return property("offset", this->_offset, o.offset);
  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("required"s == str)
    return property("required", this->_required, o.required);
  if ("noData"s == str)
    return property("noData", this->_noData, o.noData);
  if ("default"s == str)
    return property("default", this->_defaultProperty, o.defaultProperty);
  if ("semantic"s == str)
    return property("semantic", this->_semantic, o.semantic);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ClassPropertyReader::ClassPropertyReader() {
  registerReaderExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& ClassPropertyReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ClassPropertyReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::ClassProperty>
ClassPropertyReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ClassPropertyJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::ClassProperty>
ClassPropertyReader::readFromJson(const rapidjson::Value& value) const {
  ClassPropertyJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::ClassProperty>>
ClassPropertyReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<Cesium3DTiles::ClassProperty, ClassPropertyJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SubtreeJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/Subtree.h>
#include <Cesium3DTilesReader/SubtreeReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

SubtreeJsonHandler::SubtreeJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _buffers(options),
      _bufferViews(options),
      _propertyTables(options),
      _tileAvailability(options),
      _contentAvailability(options),
      _childSubtreeAvailability(options),
      _tileMetadata(),
      _contentMetadata(),
      _subtreeMetadata(options) {}

void SubtreeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Subtree* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SubtreeJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeySubtree(
      Cesium3DTiles::Subtree::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SubtreeJsonHandler::readObjectKeySubtree(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Subtree& o) {
  using namespace std::string_literals;

  if ("buffers"s == str)
    return property("buffers", this->_buffers, o.buffers);
  if ("bufferViews"s == str)
    return property("bufferViews", this->_bufferViews, o.bufferViews);
  if ("propertyTables"s == str)
    return property("propertyTables", this->_propertyTables, o.propertyTables);
  if ("tileAvailability"s == str)
    return property(
        "tileAvailability",
        this->_tileAvailability,
        o.tileAvailability);
  if ("contentAvailability"s == str)
    return property(
        "contentAvailability",
        this->_contentAvailability,
        o.contentAvailability);
  if ("childSubtreeAvailability"s == str)
    return property(
        "childSubtreeAvailability",
        this->_childSubtreeAvailability,
        o.childSubtreeAvailability);
  if ("tileMetadata"s == str)
    return property("tileMetadata", this->_tileMetadata, o.tileMetadata);
  if ("contentMetadata"s == str)
    return property(
        "contentMetadata",
        this->_contentMetadata,
        o.contentMetadata);
  if ("subtreeMetadata"s == str)
    return property(
        "subtreeMetadata",
        this->_subtreeMetadata,
        o.subtreeMetadata);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

SubtreeReader::SubtreeReader() { registerReaderExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& SubtreeReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& SubtreeReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Subtree>
SubtreeReader::readFromJson(const gsl::span<const std::byte>& data) const {
  SubtreeJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Subtree>
SubtreeReader::readFromJson(const rapidjson::Value& value) const {
  SubtreeJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::Subtree>>
SubtreeReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<Cesium3DTiles::Subtree, SubtreeJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MetadataEntityJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/MetadataEntity.h>
#include <Cesium3DTilesReader/MetadataEntityReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

MetadataEntityJsonHandler::MetadataEntityJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _classProperty(),
      _properties() {}

void MetadataEntityJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::MetadataEntity* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MetadataEntityJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyMetadataEntity(
      Cesium3DTiles::MetadataEntity::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
MetadataEntityJsonHandler::readObjectKeyMetadataEntity(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::MetadataEntity& o) {
  using namespace std::string_literals;

  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

MetadataEntityReader::MetadataEntityReader() {
  registerReaderExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& MetadataEntityReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
MetadataEntityReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::MetadataEntity>
MetadataEntityReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  MetadataEntityJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::MetadataEntity>
MetadataEntityReader::readFromJson(const rapidjson::Value& value) const {
  MetadataEntityJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::MetadataEntity>>
MetadataEntityReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<Cesium3DTiles::MetadataEntity, MetadataEntityJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AvailabilityJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/Availability.h>
#include <Cesium3DTilesReader/AvailabilityReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

AvailabilityJsonHandler::AvailabilityJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _bitstream(),
      _availableCount(),
      _constant() {}

void AvailabilityJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Availability* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AvailabilityJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyAvailability(
      Cesium3DTiles::Availability::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AvailabilityJsonHandler::readObjectKeyAvailability(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Availability& o) {
  using namespace std::string_literals;

  if ("bitstream"s == str)
    return property("bitstream", this->_bitstream, o.bitstream);
  if ("availableCount"s == str)
    return property("availableCount", this->_availableCount, o.availableCount);
  if ("constant"s == str)
    return property("constant", this->_constant, o.constant);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

AvailabilityReader::AvailabilityReader() {
  registerReaderExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& AvailabilityReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
AvailabilityReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Availability>
AvailabilityReader::readFromJson(const gsl::span<const std::byte>& data) const {
  AvailabilityJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Availability>
AvailabilityReader::readFromJson(const rapidjson::Value& value) const {
  AvailabilityJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::Availability>>
AvailabilityReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<Cesium3DTiles::Availability, AvailabilityJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyTableJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/PropertyTable.h>
#include <Cesium3DTilesReader/PropertyTableReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

PropertyTableJsonHandler::PropertyTableJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _name(),
      _classProperty(),
      _count(),
      _properties(options) {}

void PropertyTableJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::PropertyTable* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyTableJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyPropertyTable(
      Cesium3DTiles::PropertyTable::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyTableJsonHandler::readObjectKeyPropertyTable(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::PropertyTable& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

PropertyTableReader::PropertyTableReader() {
  registerReaderExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& PropertyTableReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
PropertyTableReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::PropertyTable>
PropertyTableReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  PropertyTableJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::PropertyTable>
PropertyTableReader::readFromJson(const rapidjson::Value& value) const {
  PropertyTableJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::PropertyTable>>
PropertyTableReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<Cesium3DTiles::PropertyTable, PropertyTableJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyTablePropertyJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/PropertyTableProperty.h>
#include <Cesium3DTilesReader/PropertyTablePropertyReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

PropertyTablePropertyJsonHandler::PropertyTablePropertyJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _values(),
      _arrayOffsets(),
      _stringOffsets(),
      _arrayOffsetType(),
      _stringOffsetType(),
      _offset(),
      _scale(),
      _max(),
      _min() {}

void PropertyTablePropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::PropertyTableProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyTablePropertyJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyPropertyTableProperty(
      Cesium3DTiles::PropertyTableProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyTablePropertyJsonHandler::readObjectKeyPropertyTableProperty(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::PropertyTableProperty& o) {
  using namespace std::string_literals;

  if ("values"s == str)
    return property("values", this->_values, o.values);
  if ("arrayOffsets"s == str)
    return property("arrayOffsets", this->_arrayOffsets, o.arrayOffsets);
  if ("stringOffsets"s == str)
    return property("stringOffsets", this->_stringOffsets, o.stringOffsets);
  if ("arrayOffsetType"s == str)
    return property(
        "arrayOffsetType",
        this->_arrayOffsetType,
        o.arrayOffsetType);
  if ("stringOffsetType"s == str)
    return property(
        "stringOffsetType",
        this->_stringOffsetType,
        o.stringOffsetType);
  if ("offset"s == str)
    return property("offset", this->_offset, o.offset);
  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

PropertyTablePropertyReader::PropertyTablePropertyReader() {
  registerReaderExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& PropertyTablePropertyReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
PropertyTablePropertyReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::PropertyTableProperty>
PropertyTablePropertyReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  PropertyTablePropertyJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::PropertyTableProperty>
PropertyTablePropertyReader::readFromJson(const rapidjson::Value& value) const {
  PropertyTablePropertyJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<
    std::vector<Cesium3DTiles::PropertyTableProperty>>
PropertyTablePropertyReader::readArrayFromJson(
    const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<
      Cesium3DTiles::PropertyTableProperty,
      PropertyTablePropertyJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferViewJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/BufferView.h>
#include <Cesium3DTilesReader/BufferViewReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

BufferViewJsonHandler::BufferViewJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _buffer(),
      _byteOffset(),
      _byteLength(),
      _name() {}

void BufferViewJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::BufferView* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferViewJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyBufferView(
      Cesium3DTiles::BufferView::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferViewJsonHandler::readObjectKeyBufferView(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::BufferView& o) {
  using namespace std::string_literals;

  if ("buffer"s == str)
    return property("buffer", this->_buffer, o.buffer);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

BufferViewReader::BufferViewReader() {
  registerReaderExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& BufferViewReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
BufferViewReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::BufferView>
BufferViewReader::readFromJson(const gsl::span<const std::byte>& data) const {
  BufferViewJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::BufferView>
BufferViewReader::readFromJson(const rapidjson::Value& value) const {
  BufferViewJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::BufferView>>
BufferViewReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<Cesium3DTiles::BufferView, BufferViewJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/Buffer.h>
#include <Cesium3DTilesReader/BufferReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

BufferJsonHandler::BufferJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _uri(),
      _byteLength(),
      _name() {}

void BufferJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Buffer* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyBuffer(
      Cesium3DTiles::Buffer::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferJsonHandler::readObjectKeyBuffer(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Buffer& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

BufferReader::BufferReader() { registerReaderExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& BufferReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& BufferReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Buffer>
BufferReader::readFromJson(const gsl::span<const std::byte>& data) const {
  BufferJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Buffer>
BufferReader::readFromJson(const rapidjson::Value& value) const {
  BufferJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::Buffer>>
BufferReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<Cesium3DTiles::Buffer, BufferJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TilesetJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/Tileset.h>
#include <Cesium3DTilesReader/TilesetReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

TilesetJsonHandler::TilesetJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _asset(options),
      _properties(options),
      _schema(options),
      _schemaUri(),
      _statistics(options),
      _groups(options),
      _metadata(options),
      _geometricError(),
      _root(options),
      _extensionsUsed(),
      _extensionsRequired() {}

void TilesetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Tileset* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TilesetJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyTileset(
      Cesium3DTiles::Tileset::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TilesetJsonHandler::readObjectKeyTileset(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Tileset& o) {
  using namespace std::string_literals;

  if ("asset"s == str)
    return property("asset", this->_asset, o.asset);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);
  if ("schema"s == str)
    return property("schema", this->_schema, o.schema);
  if ("schemaUri"s == str)
    return property("schemaUri", this->_schemaUri, o.schemaUri);
  if ("statistics"s == str)
    return property("statistics", this->_statistics, o.statistics);
  if ("groups"s == str)
    return property("groups", this->_groups, o.groups);
  if ("metadata"s == str)
    return property("metadata", this->_metadata, o.metadata);
  if ("geometricError"s == str)
    return property("geometricError", this->_geometricError, o.geometricError);
  if ("root"s == str)
    return property("root", this->_root, o.root);
  if ("extensionsUsed"s == str)
    return property("extensionsUsed", this->_extensionsUsed, o.extensionsUsed);
  if ("extensionsRequired"s == str)
    return property(
        "extensionsRequired",
        this->_extensionsRequired,
        o.extensionsRequired);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

TilesetReader::TilesetReader() { registerReaderExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& TilesetReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& TilesetReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Tileset>
TilesetReader::readFromJson(const gsl::span<const std::byte>& data) const {
  TilesetJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Tileset>
TilesetReader::readFromJson(const rapidjson::Value& value) const {
  TilesetJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::Tileset>>
TilesetReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<Cesium3DTiles::Tileset, TilesetJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TileJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/Tile.h>
#include <Cesium3DTilesReader/TileReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

TileJsonHandler::TileJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _boundingVolume(options),
      _viewerRequestVolume(options),
      _geometricError(),
      _refine(),
      _transform(),
      _content(options),
      _contents(options),
      _metadata(options),
      _implicitTiling(options),
      _children(options) {}

void TileJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Tile* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TileJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyTile(
      Cesium3DTiles::Tile::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TileJsonHandler::readObjectKeyTile(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Tile& o) {
  using namespace std::string_literals;

  if ("boundingVolume"s == str)
    return property("boundingVolume", this->_boundingVolume, o.boundingVolume);
  if ("viewerRequestVolume"s == str)
    return property(
        "viewerRequestVolume",
        this->_viewerRequestVolume,
        o.viewerRequestVolume);
  if ("geometricError"s == str)
    return property("geometricError", this->_geometricError, o.geometricError);
  if ("refine"s == str)
    return property("refine", this->_refine, o.refine);
  if ("transform"s == str)
    return property("transform", this->_transform, o.transform);
  if ("content"s == str)
    return property("content", this->_content, o.content);
  if ("contents"s == str)
    return property("contents", this->_contents, o.contents);
  if ("metadata"s == str)
    return property("metadata", this->_metadata, o.metadata);
  if ("implicitTiling"s == str)
    return property("implicitTiling", this->_implicitTiling, o.implicitTiling);
  if ("children"s == str)
    return property("children", this->_children, o.children);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

TileReader::TileReader() { registerReaderExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& TileReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& TileReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Tile>
TileReader::readFromJson(const gsl::span<const std::byte>& data) const {
  TileJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Tile>
TileReader::readFromJson(const rapidjson::Value& value) const {
  TileJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::Tile>>
TileReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<Cesium3DTiles::Tile, TileJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ImplicitTilingJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/ImplicitTiling.h>
#include <Cesium3DTilesReader/ImplicitTilingReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

ImplicitTilingJsonHandler::ImplicitTilingJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _subdivisionScheme(),
      _subtreeLevels(),
      _availableLevels(),
      _subtrees(options) {}

void ImplicitTilingJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::ImplicitTiling* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ImplicitTilingJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyImplicitTiling(
      Cesium3DTiles::ImplicitTiling::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ImplicitTilingJsonHandler::readObjectKeyImplicitTiling(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::ImplicitTiling& o) {
  using namespace std::string_literals;

  if ("subdivisionScheme"s == str)
    return property(
        "subdivisionScheme",
        this->_subdivisionScheme,
        o.subdivisionScheme);
  if ("subtreeLevels"s == str)
    return property("subtreeLevels", this->_subtreeLevels, o.subtreeLevels);
  if ("availableLevels"s == str)
    return property(
        "availableLevels",
        this->_availableLevels,
        o.availableLevels);
  if ("subtrees"s == str)
    return property("subtrees", this->_subtrees, o.subtrees);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ImplicitTilingReader::ImplicitTilingReader() {
  registerReaderExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& ImplicitTilingReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
ImplicitTilingReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::ImplicitTiling>
ImplicitTilingReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  ImplicitTilingJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::ImplicitTiling>
ImplicitTilingReader::readFromJson(const rapidjson::Value& value) const {
  ImplicitTilingJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::ImplicitTiling>>
ImplicitTilingReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<Cesium3DTiles::ImplicitTiling, ImplicitTilingJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SubtreesJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/Subtrees.h>
#include <Cesium3DTilesReader/SubtreesReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

SubtreesJsonHandler::SubtreesJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options), _uri() {}

void SubtreesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Subtrees* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SubtreesJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeySubtrees(
      Cesium3DTiles::Subtrees::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SubtreesJsonHandler::readObjectKeySubtrees(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Subtrees& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

SubtreesReader::SubtreesReader() { registerReaderExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& SubtreesReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& SubtreesReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Subtrees>
SubtreesReader::readFromJson(const gsl::span<const std::byte>& data) const {
  SubtreesJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Subtrees>
SubtreesReader::readFromJson(const rapidjson::Value& value) const {
  SubtreesJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::Subtrees>>
SubtreesReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<Cesium3DTiles::Subtrees, SubtreesJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ContentJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/Content.h>
#include <Cesium3DTilesReader/ContentReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

ContentJsonHandler::ContentJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _boundingVolume(options),
      _uri(),
      _metadata(options),
      _group() {}

void ContentJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Content* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ContentJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyContent(
      Cesium3DTiles::Content::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ContentJsonHandler::readObjectKeyContent(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Content& o) {
  using namespace std::string_literals;

  if ("boundingVolume"s == str)
    return property("boundingVolume", this->_boundingVolume, o.boundingVolume);
  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);
  if ("metadata"s == str)
    return property("metadata", this->_metadata, o.metadata);
  if ("group"s == str)
    return property("group", this->_group, o.group);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

ContentReader::ContentReader() { registerReaderExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& ContentReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& ContentReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Content>
ContentReader::readFromJson(const gsl::span<const std::byte>& data) const {
  ContentJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Content>
ContentReader::readFromJson(const rapidjson::Value& value) const {
  ContentJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::Content>>
ContentReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<Cesium3DTiles::Content, ContentJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BoundingVolumeJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/BoundingVolume.h>
#include <Cesium3DTilesReader/BoundingVolumeReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

BoundingVolumeJsonHandler::BoundingVolumeJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _box(),
      _region(),
      _sphere() {}

void BoundingVolumeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::BoundingVolume* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BoundingVolumeJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyBoundingVolume(
      Cesium3DTiles::BoundingVolume::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
BoundingVolumeJsonHandler::readObjectKeyBoundingVolume(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::BoundingVolume& o) {
  using namespace std::string_literals;

  if ("box"s == str)
    return property("box", this->_box, o.box);
  if ("region"s == str)
    return property("region", this->_region, o.region);
  if ("sphere"s == str)
    return property("sphere", this->_sphere, o.sphere);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

BoundingVolumeReader::BoundingVolumeReader() {
  registerReaderExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& BoundingVolumeReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
BoundingVolumeReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::BoundingVolume>
BoundingVolumeReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  BoundingVolumeJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::BoundingVolume>
BoundingVolumeReader::readFromJson(const rapidjson::Value& value) const {
  BoundingVolumeJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::BoundingVolume>>
BoundingVolumeReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<Cesium3DTiles::BoundingVolume, BoundingVolumeJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "GroupMetadataJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/GroupMetadata.h>
#include <Cesium3DTilesReader/GroupMetadataReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

GroupMetadataJsonHandler::GroupMetadataJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : MetadataEntityJsonHandler(options) {}

void GroupMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::GroupMetadata* pObject) {
  MetadataEntityJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
GroupMetadataJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyGroupMetadata(
      Cesium3DTiles::GroupMetadata::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
GroupMetadataJsonHandler::readObjectKeyGroupMetadata(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::GroupMetadata& o) {
  using namespace std::string_literals;

  (void)o;

  return this->readObjectKeyMetadataEntity(objectType, str, *this->_pObject);
}

GroupMetadataReader::GroupMetadataReader() {
  registerReaderExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& GroupMetadataReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
GroupMetadataReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::GroupMetadata>
GroupMetadataReader::readFromJson(
    const gsl::span<const std::byte>& data) const {
  GroupMetadataJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::GroupMetadata>
GroupMetadataReader::readFromJson(const rapidjson::Value& value) const {
  GroupMetadataJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::GroupMetadata>>
GroupMetadataReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<Cesium3DTiles::GroupMetadata, GroupMetadataJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertiesJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/Properties.h>
#include <Cesium3DTilesReader/PropertiesReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

PropertiesJsonHandler::PropertiesJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _maximum(),
      _minimum() {}

void PropertiesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Properties* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertiesJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyProperties(
      Cesium3DTiles::Properties::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* PropertiesJsonHandler::readObjectKeyProperties(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Properties& o) {
  using namespace std::string_literals;

  if ("maximum"s == str)
    return property("maximum", this->_maximum, o.maximum);
  if ("minimum"s == str)
    return property("minimum", this->_minimum, o.minimum);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

PropertiesReader::PropertiesReader() {
  registerReaderExtensions(this->_options);
}

CesiumJsonReader::JsonReaderOptions& PropertiesReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions&
PropertiesReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Properties>
PropertiesReader::readFromJson(const gsl::span<const std::byte>& data) const {
  PropertiesJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Properties>
PropertiesReader::readFromJson(const rapidjson::Value& value) const {
  PropertiesJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::Properties>>
PropertiesReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::
      ArrayJsonHandler<Cesium3DTiles::Properties, PropertiesJsonHandler>
          handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AssetJsonHandler.h"
#include "registerReaderExtensions.h"

#include <Cesium3DTiles/Asset.h>
#include <Cesium3DTilesReader/AssetReader.h>
#include <CesiumJsonReader/ArrayJsonHandler.h>
#include <CesiumJsonReader/JsonReader.h>
#include <CesiumUtility/Assert.h>

#include <string>

namespace Cesium3DTilesReader {

AssetJsonHandler::AssetJsonHandler(
    const CesiumJsonReader::JsonReaderOptions& options) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(options),
      _version(),
      _tilesetVersion() {}

void AssetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Asset* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AssetJsonHandler::readObjectKey(const std::string_view& str) {
  CESIUM_ASSERT(this->_pObject);
  return this->readObjectKeyAsset(
      Cesium3DTiles::Asset::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AssetJsonHandler::readObjectKeyAsset(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Asset& o) {
  using namespace std::string_literals;

  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("tilesetVersion"s == str)
    return property("tilesetVersion", this->_tilesetVersion, o.tilesetVersion);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

AssetReader::AssetReader() { registerReaderExtensions(this->_options); }

CesiumJsonReader::JsonReaderOptions& AssetReader::getOptions() {
  return this->_options;
}

const CesiumJsonReader::JsonReaderOptions& AssetReader::getOptions() const {
  return this->_options;
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Asset>
AssetReader::readFromJson(const gsl::span<const std::byte>& data) const {
  AssetJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(data, handler);
}

CesiumJsonReader::ReadJsonResult<Cesium3DTiles::Asset>
AssetReader::readFromJson(const rapidjson::Value& value) const {
  AssetJsonHandler handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

CesiumJsonReader::ReadJsonResult<std::vector<Cesium3DTiles::Asset>>
AssetReader::readArrayFromJson(const rapidjson::Value& value) const {
  CesiumJsonReader::ArrayJsonHandler<Cesium3DTiles::Asset, AssetJsonHandler>
      handler(this->_options);
  return CesiumJsonReader::JsonReader::readJson(value, handler);
}

} // namespace Cesium3DTilesReader
