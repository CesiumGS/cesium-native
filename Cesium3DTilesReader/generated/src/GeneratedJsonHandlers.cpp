// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesBoundingVolumeS2JsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesBoundingVolumeS2.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesBoundingVolumeS2JsonHandler::
    Extension3dTilesBoundingVolumeS2JsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _token(),
      _minimumHeight(),
      _maximumHeight() {}

void Extension3dTilesBoundingVolumeS2JsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesBoundingVolumeS2* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesBoundingVolumeS2JsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesBoundingVolumeS2(
      Cesium3DTiles::Extension3dTilesBoundingVolumeS2::TypeName,
      str,
      *this->_pObject);
}

void Extension3dTilesBoundingVolumeS2JsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            Cesium3DTiles::Extension3dTilesBoundingVolumeS2())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::Extension3dTilesBoundingVolumeS2&>(value));
}

CesiumJsonReader::IJsonHandler* Extension3dTilesBoundingVolumeS2JsonHandler::
    readObjectKeyExtension3dTilesBoundingVolumeS2(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesBoundingVolumeS2& o) {
  using namespace std::string_literals;

  if ("token"s == str)
    return property("token", this->_token, o.token);
  if ("minimumHeight"s == str)
    return property("minimumHeight", this->_minimumHeight, o.minimumHeight);
  if ("maximumHeight"s == str)
    return property("maximumHeight", this->_maximumHeight, o.maximumHeight);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesContentGltfJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesContentGltf.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesContentGltfJsonHandler::Extension3dTilesContentGltfJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _extensionsUsed(),
      _extensionsRequired() {}

void Extension3dTilesContentGltfJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesContentGltf* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesContentGltfJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesContentGltf(
      Cesium3DTiles::Extension3dTilesContentGltf::TypeName,
      str,
      *this->_pObject);
}

void Extension3dTilesContentGltfJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, Cesium3DTiles::Extension3dTilesContentGltf())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::Extension3dTilesContentGltf&>(value));
}

CesiumJsonReader::IJsonHandler* Extension3dTilesContentGltfJsonHandler::
    readObjectKeyExtension3dTilesContentGltf(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesContentGltf& o) {
  using namespace std::string_literals;

  if ("extensionsUsed"s == str)
    return property("extensionsUsed", this->_extensionsUsed, o.extensionsUsed);
  if ("extensionsRequired"s == str)
    return property(
        "extensionsRequired",
        this->_extensionsRequired,
        o.extensionsRequired);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesImplicitTilingJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesImplicitTiling.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesImplicitTilingJsonHandler::
    Extension3dTilesImplicitTilingJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _subdivisionScheme(),
      _subtreeLevels(),
      _availableLevels(),
      _subtrees(context) {}

void Extension3dTilesImplicitTilingJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesImplicitTiling* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesImplicitTilingJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesImplicitTiling(
      Cesium3DTiles::Extension3dTilesImplicitTiling::TypeName,
      str,
      *this->_pObject);
}

void Extension3dTilesImplicitTilingJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            Cesium3DTiles::Extension3dTilesImplicitTiling())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::Extension3dTilesImplicitTiling&>(value));
}

CesiumJsonReader::IJsonHandler* Extension3dTilesImplicitTilingJsonHandler::
    readObjectKeyExtension3dTilesImplicitTiling(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesImplicitTiling& o) {
  using namespace std::string_literals;

  if ("subdivisionScheme"s == str)
    return property(
        "subdivisionScheme",
        this->_subdivisionScheme,
        o.subdivisionScheme);
  if ("subtreeLevels"s == str)
    return property("subtreeLevels", this->_subtreeLevels, o.subtreeLevels);
  if ("availableLevels"s == str)
    return property(
        "availableLevels",
        this->_availableLevels,
        o.availableLevels);
  if ("subtrees"s == str)
    return property("subtrees", this->_subtrees, o.subtrees);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionContent3dTilesMetadataJsonHandler.h"

#include <Cesium3DTiles/ExtensionContent3dTilesMetadata.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ExtensionContent3dTilesMetadataJsonHandler::
    ExtensionContent3dTilesMetadataJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : MetadataEntityJsonHandler(context), _group() {}

void ExtensionContent3dTilesMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::ExtensionContent3dTilesMetadata* pObject) {
  MetadataEntityJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionContent3dTilesMetadataJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionContent3dTilesMetadata(
      Cesium3DTiles::ExtensionContent3dTilesMetadata::TypeName,
      str,
      *this->_pObject);
}

void ExtensionContent3dTilesMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            Cesium3DTiles::ExtensionContent3dTilesMetadata())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::ExtensionContent3dTilesMetadata&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionContent3dTilesMetadataJsonHandler::
    readObjectKeyExtensionContent3dTilesMetadata(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::ExtensionContent3dTilesMetadata& o) {
  using namespace std::string_literals;

  if ("group"s == str)
    return property("group", this->_group, o.group);

  return this->readObjectKeyMetadataEntity(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionTile3dTilesMetadataJsonHandler.h"

#include <Cesium3DTiles/ExtensionTile3dTilesMetadata.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ExtensionTile3dTilesMetadataJsonHandler::
    ExtensionTile3dTilesMetadataJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : MetadataEntityJsonHandler(context) {}

void ExtensionTile3dTilesMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::ExtensionTile3dTilesMetadata* pObject) {
  MetadataEntityJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionTile3dTilesMetadataJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionTile3dTilesMetadata(
      Cesium3DTiles::ExtensionTile3dTilesMetadata::TypeName,
      str,
      *this->_pObject);
}

void ExtensionTile3dTilesMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, Cesium3DTiles::ExtensionTile3dTilesMetadata())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::ExtensionTile3dTilesMetadata&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionTile3dTilesMetadataJsonHandler::
    readObjectKeyExtensionTile3dTilesMetadata(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::ExtensionTile3dTilesMetadata& o) {
  using namespace std::string_literals;

  (void)o;

  return this->readObjectKeyMetadataEntity(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ExtensionTileset3dTilesMetadataJsonHandler.h"

#include <Cesium3DTiles/ExtensionTileset3dTilesMetadata.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ExtensionTileset3dTilesMetadataJsonHandler::
    ExtensionTileset3dTilesMetadataJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _schema(context),
      _schemaUri(),
      _statistics(context),
      _groups(context),
      _tileset(context) {}

void ExtensionTileset3dTilesMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::ExtensionTileset3dTilesMetadata* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ExtensionTileset3dTilesMetadataJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtensionTileset3dTilesMetadata(
      Cesium3DTiles::ExtensionTileset3dTilesMetadata::TypeName,
      str,
      *this->_pObject);
}

void ExtensionTileset3dTilesMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            Cesium3DTiles::ExtensionTileset3dTilesMetadata())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::ExtensionTileset3dTilesMetadata&>(value));
}

CesiumJsonReader::IJsonHandler* ExtensionTileset3dTilesMetadataJsonHandler::
    readObjectKeyExtensionTileset3dTilesMetadata(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::ExtensionTileset3dTilesMetadata& o) {
  using namespace std::string_literals;

  if ("schema"s == str)
    return property("schema", this->_schema, o.schema);
  if ("schemaUri"s == str)
    return property("schemaUri", this->_schemaUri, o.schemaUri);
  if ("statistics"s == str)
    return property("statistics", this->_statistics, o.statistics);
  if ("groups"s == str)
    return property("groups", this->_groups, o.groups);
  if ("tileset"s == str)
    return property("tileset", this->_tileset, o.tileset);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesMultipleContentsJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesMultipleContents.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesMultipleContentsJsonHandler::
    Extension3dTilesMultipleContentsJsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _content(context) {}

void Extension3dTilesMultipleContentsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesMultipleContents* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesMultipleContentsJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesMultipleContents(
      Cesium3DTiles::Extension3dTilesMultipleContents::TypeName,
      str,
      *this->_pObject);
}

void Extension3dTilesMultipleContentsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            Cesium3DTiles::Extension3dTilesMultipleContents())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::Extension3dTilesMultipleContents&>(value));
}

CesiumJsonReader::IJsonHandler* Extension3dTilesMultipleContentsJsonHandler::
    readObjectKeyExtension3dTilesMultipleContents(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesMultipleContents& o) {
  using namespace std::string_literals;

  if ("content"s == str)
    return property("content", this->_content, o.content);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ContentJsonHandler.h"

#include <Cesium3DTiles/Content.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ContentJsonHandler::ContentJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _boundingVolume(context),
      _uri() {}

void ContentJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Content* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ContentJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyContent(
      Cesium3DTiles::Content::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ContentJsonHandler::readObjectKeyContent(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Content& o) {
  using namespace std::string_literals;

  if ("boundingVolume"s == str)
    return property("boundingVolume", this->_boundingVolume, o.boundingVolume);
  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BoundingVolumeJsonHandler.h"

#include <Cesium3DTiles/BoundingVolume.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

BoundingVolumeJsonHandler::BoundingVolumeJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _box(),
      _region(),
      _sphere() {}

void BoundingVolumeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::BoundingVolume* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BoundingVolumeJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBoundingVolume(
      Cesium3DTiles::BoundingVolume::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
BoundingVolumeJsonHandler::readObjectKeyBoundingVolume(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::BoundingVolume& o) {
  using namespace std::string_literals;

  if ("box"s == str)
    return property("box", this->_box, o.box);
  if ("region"s == str)
    return property("region", this->_region, o.region);
  if ("sphere"s == str)
    return property("sphere", this->_sphere, o.sphere);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TilesetMetadataJsonHandler.h"

#include <Cesium3DTiles/TilesetMetadata.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

TilesetMetadataJsonHandler::TilesetMetadataJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : MetadataEntityJsonHandler(context) {}

void TilesetMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::TilesetMetadata* pObject) {
  MetadataEntityJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TilesetMetadataJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTilesetMetadata(
      Cesium3DTiles::TilesetMetadata::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
TilesetMetadataJsonHandler::readObjectKeyTilesetMetadata(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::TilesetMetadata& o) {
  using namespace std::string_literals;

  (void)o;

  return this->readObjectKeyMetadataEntity(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "MetadataEntityJsonHandler.h"

#include <Cesium3DTiles/MetadataEntity.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

MetadataEntityJsonHandler::MetadataEntityJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _classProperty(),
      _properties() {}

void MetadataEntityJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::MetadataEntity* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
MetadataEntityJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyMetadataEntity(
      Cesium3DTiles::MetadataEntity::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
MetadataEntityJsonHandler::readObjectKeyMetadataEntity(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::MetadataEntity& o) {
  using namespace std::string_literals;

  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "GroupMetadataJsonHandler.h"

#include <Cesium3DTiles/GroupMetadata.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

GroupMetadataJsonHandler::GroupMetadataJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : MetadataEntityJsonHandler(context) {}

void GroupMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::GroupMetadata* pObject) {
  MetadataEntityJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
GroupMetadataJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyGroupMetadata(
      Cesium3DTiles::GroupMetadata::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
GroupMetadataJsonHandler::readObjectKeyGroupMetadata(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::GroupMetadata& o) {
  using namespace std::string_literals;

  (void)o;

  return this->readObjectKeyMetadataEntity(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "StatisticsJsonHandler.h"

#include <Cesium3DTiles/Statistics.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

StatisticsJsonHandler::StatisticsJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _classes(context) {}

void StatisticsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Statistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
StatisticsJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyStatistics(
      Cesium3DTiles::Statistics::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* StatisticsJsonHandler::readObjectKeyStatistics(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Statistics& o) {
  using namespace std::string_literals;

  if ("classes"s == str)
    return property("classes", this->_classes, o.classes);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassStatisticsJsonHandler.h"

#include <Cesium3DTiles/ClassStatistics.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ClassStatisticsJsonHandler::ClassStatisticsJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _count(),
      _properties(context) {}

void ClassStatisticsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::ClassStatistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ClassStatisticsJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyClassStatistics(
      Cesium3DTiles::ClassStatistics::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ClassStatisticsJsonHandler::readObjectKeyClassStatistics(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::ClassStatistics& o) {
  using namespace std::string_literals;

  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyStatisticsJsonHandler.h"

#include <Cesium3DTiles/PropertyStatistics.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

PropertyStatisticsJsonHandler::PropertyStatisticsJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _min(),
      _max(),
      _mean(),
      _median(),
      _standardDeviation(),
      _variance(),
      _sum(),
      _occurrences() {}

void PropertyStatisticsJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::PropertyStatistics* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyStatisticsJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyPropertyStatistics(
      Cesium3DTiles::PropertyStatistics::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyStatisticsJsonHandler::readObjectKeyPropertyStatistics(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::PropertyStatistics& o) {
  using namespace std::string_literals;

  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("mean"s == str)
    return property("mean", this->_mean, o.mean);
  if ("median"s == str)
    return property("median", this->_median, o.median);
  if ("standardDeviation"s == str)
    return property(
        "standardDeviation",
        this->_standardDeviation,
        o.standardDeviation);
  if ("variance"s == str)
    return property("variance", this->_variance, o.variance);
  if ("sum"s == str)
    return property("sum", this->_sum, o.sum);
  if ("occurrences"s == str)
    return property("occurrences", this->_occurrences, o.occurrences);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SchemaJsonHandler.h"

#include <Cesium3DTiles/Schema.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

SchemaJsonHandler::SchemaJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _id(),
      _name(),
      _description(),
      _version(),
      _classes(context),
      _enums(context) {}

void SchemaJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Schema* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SchemaJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySchema(
      Cesium3DTiles::Schema::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SchemaJsonHandler::readObjectKeySchema(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Schema& o) {
  using namespace std::string_literals;

  if ("id"s == str)
    return property("id", this->_id, o.id);
  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("classes"s == str)
    return property("classes", this->_classes, o.classes);
  if ("enums"s == str)
    return property("enums", this->_enums, o.enums);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "EnumJsonHandler.h"

#include <Cesium3DTiles/Enum.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

EnumJsonHandler::EnumJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _valueType(),
      _values(context) {}

void EnumJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Enum* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
EnumJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyEnum(
      Cesium3DTiles::Enum::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* EnumJsonHandler::readObjectKeyEnum(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Enum& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("valueType"s == str)
    return property("valueType", this->_valueType, o.valueType);
  if ("values"s == str)
    return property("values", this->_values, o.values);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "EnumValueJsonHandler.h"

#include <Cesium3DTiles/EnumValue.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

EnumValueJsonHandler::EnumValueJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _value() {}

void EnumValueJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::EnumValue* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
EnumValueJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyEnumValue(
      Cesium3DTiles::EnumValue::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* EnumValueJsonHandler::readObjectKeyEnumValue(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::EnumValue& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("value"s == str)
    return property("value", this->_value, o.value);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassJsonHandler.h"

#include <Cesium3DTiles/Class.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ClassJsonHandler::ClassJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _properties(context) {}

void ClassJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Class* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ClassJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyClass(
      Cesium3DTiles::Class::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ClassJsonHandler::readObjectKeyClass(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Class& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ClassPropertyJsonHandler.h"

#include <Cesium3DTiles/ClassProperty.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ClassPropertyJsonHandler::ClassPropertyJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _description(),
      _type(),
      _componentType(),
      _enumType(),
      _count(),
      _hasFixedCount(),
      _normalized(),
      _offset(),
      _scale(),
      _max(),
      _min(),
      _required(),
      _noData(),
      _defaultProperty(),
      _semantic() {}

void ClassPropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::ClassProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ClassPropertyJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyClassProperty(
      Cesium3DTiles::ClassProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
ClassPropertyJsonHandler::readObjectKeyClassProperty(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::ClassProperty& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("description"s == str)
    return property("description", this->_description, o.description);
  if ("type"s == str)
    return property("type", this->_type, o.type);
  if ("componentType"s == str)
    return property("componentType", this->_componentType, o.componentType);
  if ("enumType"s == str)
    return property("enumType", this->_enumType, o.enumType);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("hasFixedCount"s == str)
    return property("hasFixedCount", this->_hasFixedCount, o.hasFixedCount);
  if ("normalized"s == str)
    return property("normalized", this->_normalized, o.normalized);
  if ("offset"s == str)
    return property("offset", this->_offset, o.offset);
  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);
  if ("required"s == str)
    return property("required", this->_required, o.required);
  if ("noData"s == str)
    return property("noData", this->_noData, o.noData);
  if ("default"s == str)
    return property("default", this->_defaultProperty, o.defaultProperty);
  if ("semantic"s == str)
    return property("semantic", this->_semantic, o.semantic);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SubtreesJsonHandler.h"

#include <Cesium3DTiles/Subtrees.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

SubtreesJsonHandler::SubtreesJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context), _uri() {}

void SubtreesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Subtrees* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SubtreesJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySubtrees(
      Cesium3DTiles::Subtrees::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SubtreesJsonHandler::readObjectKeySubtrees(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Subtrees& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SubtreeJsonHandler.h"

#include <Cesium3DTiles/Subtree.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

SubtreeJsonHandler::SubtreeJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _buffers(context),
      _bufferViews(context),
      _tileAvailability(context),
      _contentAvailability(context),
      _childSubtreeAvailability(context),
      _tileMetadata(context),
      _contentMetadata(context),
      _subtreeMetadata(context) {}

void SubtreeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Subtree* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SubtreeJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySubtree(
      Cesium3DTiles::Subtree::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* SubtreeJsonHandler::readObjectKeySubtree(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Subtree& o) {
  using namespace std::string_literals;

  if ("buffers"s == str)
    return property("buffers", this->_buffers, o.buffers);
  if ("bufferViews"s == str)
    return property("bufferViews", this->_bufferViews, o.bufferViews);
  if ("tileAvailability"s == str)
    return property(
        "tileAvailability",
        this->_tileAvailability,
        o.tileAvailability);
  if ("contentAvailability"s == str)
    return property(
        "contentAvailability",
        this->_contentAvailability,
        o.contentAvailability);
  if ("childSubtreeAvailability"s == str)
    return property(
        "childSubtreeAvailability",
        this->_childSubtreeAvailability,
        o.childSubtreeAvailability);
  if ("tileMetadata"s == str)
    return property("tileMetadata", this->_tileMetadata, o.tileMetadata);
  if ("contentMetadata"s == str)
    return property(
        "contentMetadata",
        this->_contentMetadata,
        o.contentMetadata);
  if ("subtreeMetadata"s == str)
    return property(
        "subtreeMetadata",
        this->_subtreeMetadata,
        o.subtreeMetadata);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "SubtreeMetadataJsonHandler.h"

#include <Cesium3DTiles/SubtreeMetadata.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

SubtreeMetadataJsonHandler::SubtreeMetadataJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _classProperty(),
      _properties() {}

void SubtreeMetadataJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::SubtreeMetadata* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
SubtreeMetadataJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeySubtreeMetadata(
      Cesium3DTiles::SubtreeMetadata::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
SubtreeMetadataJsonHandler::readObjectKeySubtreeMetadata(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::SubtreeMetadata& o) {
  using namespace std::string_literals;

  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyTableJsonHandler.h"

#include <Cesium3DTiles/PropertyTable.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

PropertyTableJsonHandler::PropertyTableJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _name(),
      _classProperty(),
      _count(),
      _properties(context) {}

void PropertyTableJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::PropertyTable* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyTableJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyPropertyTable(
      Cesium3DTiles::PropertyTable::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyTableJsonHandler::readObjectKeyPropertyTable(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::PropertyTable& o) {
  using namespace std::string_literals;

  if ("name"s == str)
    return property("name", this->_name, o.name);
  if ("class"s == str)
    return property("class", this->_classProperty, o.classProperty);
  if ("count"s == str)
    return property("count", this->_count, o.count);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertyTablePropertyJsonHandler.h"

#include <Cesium3DTiles/PropertyTableProperty.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

PropertyTablePropertyJsonHandler::PropertyTablePropertyJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _values(),
      _arrayOffsets(),
      _stringOffsets(),
      _arrayOffsetType(),
      _stringOffsetType(),
      _offset(),
      _scale(),
      _max(),
      _min() {}

void PropertyTablePropertyJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::PropertyTableProperty* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertyTablePropertyJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyPropertyTableProperty(
      Cesium3DTiles::PropertyTableProperty::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
PropertyTablePropertyJsonHandler::readObjectKeyPropertyTableProperty(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::PropertyTableProperty& o) {
  using namespace std::string_literals;

  if ("values"s == str)
    return property("values", this->_values, o.values);
  if ("arrayOffsets"s == str)
    return property("arrayOffsets", this->_arrayOffsets, o.arrayOffsets);
  if ("stringOffsets"s == str)
    return property("stringOffsets", this->_stringOffsets, o.stringOffsets);
  if ("arrayOffsetType"s == str)
    return property(
        "arrayOffsetType",
        this->_arrayOffsetType,
        o.arrayOffsetType);
  if ("stringOffsetType"s == str)
    return property(
        "stringOffsetType",
        this->_stringOffsetType,
        o.stringOffsetType);
  if ("offset"s == str)
    return property("offset", this->_offset, o.offset);
  if ("scale"s == str)
    return property("scale", this->_scale, o.scale);
  if ("max"s == str)
    return property("max", this->_max, o.max);
  if ("min"s == str)
    return property("min", this->_min, o.min);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AvailabilityJsonHandler.h"

#include <Cesium3DTiles/Availability.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

AvailabilityJsonHandler::AvailabilityJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _bitstream(),
      _availableCount(),
      _constant() {}

void AvailabilityJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Availability* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AvailabilityJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAvailability(
      Cesium3DTiles::Availability::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
AvailabilityJsonHandler::readObjectKeyAvailability(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Availability& o) {
  using namespace std::string_literals;

  if ("bitstream"s == str)
    return property("bitstream", this->_bitstream, o.bitstream);
  if ("availableCount"s == str)
    return property("availableCount", this->_availableCount, o.availableCount);
  if ("constant"s == str)
    return property("constant", this->_constant, o.constant);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferViewJsonHandler.h"

#include <Cesium3DTiles/BufferView.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

BufferViewJsonHandler::BufferViewJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _buffer(),
      _byteOffset(),
      _byteLength(),
      _name() {}

void BufferViewJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::BufferView* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferViewJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBufferView(
      Cesium3DTiles::BufferView::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferViewJsonHandler::readObjectKeyBufferView(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::BufferView& o) {
  using namespace std::string_literals;

  if ("buffer"s == str)
    return property("buffer", this->_buffer, o.buffer);
  if ("byteOffset"s == str)
    return property("byteOffset", this->_byteOffset, o.byteOffset);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BufferJsonHandler.h"

#include <Cesium3DTiles/Buffer.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

BufferJsonHandler::BufferJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _uri(),
      _byteLength(),
      _name() {}

void BufferJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Buffer* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BufferJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBuffer(
      Cesium3DTiles::Buffer::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* BufferJsonHandler::readObjectKeyBuffer(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Buffer& o) {
  using namespace std::string_literals;

  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);
  if ("byteLength"s == str)
    return property("byteLength", this->_byteLength, o.byteLength);
  if ("name"s == str)
    return property("name", this->_name, o.name);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TilesetJsonHandler.h"

#include <Cesium3DTiles/Tileset.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

TilesetJsonHandler::TilesetJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _asset(context),
      _properties(context),
      _geometricError(),
      _root(context),
      _extensionsUsed(),
      _extensionsRequired() {}

void TilesetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Tileset* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TilesetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTileset(
      Cesium3DTiles::Tileset::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TilesetJsonHandler::readObjectKeyTileset(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Tileset& o) {
  using namespace std::string_literals;

  if ("asset"s == str)
    return property("asset", this->_asset, o.asset);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);
  if ("geometricError"s == str)
    return property("geometricError", this->_geometricError, o.geometricError);
  if ("root"s == str)
    return property("root", this->_root, o.root);
  if ("extensionsUsed"s == str)
    return property("extensionsUsed", this->_extensionsUsed, o.extensionsUsed);
  if ("extensionsRequired"s == str)
    return property(
        "extensionsRequired",
        this->_extensionsRequired,
        o.extensionsRequired);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TileJsonHandler.h"

#include <Cesium3DTiles/Tile.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

TileJsonHandler::TileJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _boundingVolume(context),
      _viewerRequestVolume(context),
      _geometricError(),
      _refine(),
      _transform(),
      _content(context),
      _children(context) {}

void TileJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Tile* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TileJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTile(
      Cesium3DTiles::Tile::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TileJsonHandler::readObjectKeyTile(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Tile& o) {
  using namespace std::string_literals;

  if ("boundingVolume"s == str)
    return property("boundingVolume", this->_boundingVolume, o.boundingVolume);
  if ("viewerRequestVolume"s == str)
    return property(
        "viewerRequestVolume",
        this->_viewerRequestVolume,
        o.viewerRequestVolume);
  if ("geometricError"s == str)
    return property("geometricError", this->_geometricError, o.geometricError);
  if ("refine"s == str)
    return property("refine", this->_refine, o.refine);
  if ("transform"s == str)
    return property("transform", this->_transform, o.transform);
  if ("content"s == str)
    return property("content", this->_content, o.content);
  if ("children"s == str)
    return property("children", this->_children, o.children);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertiesJsonHandler.h"

#include <Cesium3DTiles/Properties.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

PropertiesJsonHandler::PropertiesJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _maximum(),
      _minimum() {}

void PropertiesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Properties* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertiesJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyProperties(
      Cesium3DTiles::Properties::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* PropertiesJsonHandler::readObjectKeyProperties(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Properties& o) {
  using namespace std::string_literals;

  if ("maximum"s == str)
    return property("maximum", this->_maximum, o.maximum);
  if ("minimum"s == str)
    return property("minimum", this->_minimum, o.minimum);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AssetJsonHandler.h"

#include <Cesium3DTiles/Asset.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

AssetJsonHandler::AssetJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _version(),
      _tilesetVersion() {}

void AssetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Asset* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AssetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAsset(
      Cesium3DTiles::Asset::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AssetJsonHandler::readObjectKeyAsset(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Asset& o) {
  using namespace std::string_literals;

  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("tilesetVersion"s == str)
    return property("tilesetVersion", this->_tilesetVersion, o.tilesetVersion);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

} // namespace Cesium3DTilesReader
