// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesContentGltfJsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesContentGltf.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesContentGltfJsonHandler::Extension3dTilesContentGltfJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _extensionsUsed(),
      _extensionsRequired() {}

void Extension3dTilesContentGltfJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesContentGltf* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesContentGltfJsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesContentGltf(
      Cesium3DTiles::Extension3dTilesContentGltf::TypeName,
      str,
      *this->_pObject);
}

void Extension3dTilesContentGltfJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value =
      o.extensions
          .emplace(extensionName, Cesium3DTiles::Extension3dTilesContentGltf())
          .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::Extension3dTilesContentGltf&>(value));
}

CesiumJsonReader::IJsonHandler* Extension3dTilesContentGltfJsonHandler::
    readObjectKeyExtension3dTilesContentGltf(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesContentGltf& o) {
  using namespace std::string_literals;

  if ("extensionsUsed"s == str)
    return property("extensionsUsed", this->_extensionsUsed, o.extensionsUsed);
  if ("extensionsRequired"s == str)
    return property(
        "extensionsRequired",
        this->_extensionsRequired,
        o.extensionsRequired);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

void Extension3dTilesContentGltfJsonHandler::populateExtensions(
    CesiumJsonReader::ExtensionReaderContext& context) {
  (void)context;
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "Extension3dTilesBoundingVolumeS2JsonHandler.h"

#include <Cesium3DTiles/Extension3dTilesBoundingVolumeS2.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

Extension3dTilesBoundingVolumeS2JsonHandler::
    Extension3dTilesBoundingVolumeS2JsonHandler(
        const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _token(),
      _minimumHeight(),
      _maximumHeight() {}

void Extension3dTilesBoundingVolumeS2JsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Extension3dTilesBoundingVolumeS2* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
Extension3dTilesBoundingVolumeS2JsonHandler::readObjectKey(
    const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyExtension3dTilesBoundingVolumeS2(
      Cesium3DTiles::Extension3dTilesBoundingVolumeS2::TypeName,
      str,
      *this->_pObject);
}

void Extension3dTilesBoundingVolumeS2JsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    CesiumUtility::ExtensibleObject& o,
    const std::string_view& extensionName) {
  std::any& value = o.extensions
                        .emplace(
                            extensionName,
                            Cesium3DTiles::Extension3dTilesBoundingVolumeS2())
                        .first->second;
  this->reset(
      pParentHandler,
      &std::any_cast<Cesium3DTiles::Extension3dTilesBoundingVolumeS2&>(value));
}

CesiumJsonReader::IJsonHandler* Extension3dTilesBoundingVolumeS2JsonHandler::
    readObjectKeyExtension3dTilesBoundingVolumeS2(
        const std::string& objectType,
        const std::string_view& str,
        Cesium3DTiles::Extension3dTilesBoundingVolumeS2& o) {
  using namespace std::string_literals;

  if ("token"s == str)
    return property("token", this->_token, o.token);
  if ("minimumHeight"s == str)
    return property("minimumHeight", this->_minimumHeight, o.minimumHeight);
  if ("maximumHeight"s == str)
    return property("maximumHeight", this->_maximumHeight, o.maximumHeight);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

void Extension3dTilesBoundingVolumeS2JsonHandler::populateExtensions(
    CesiumJsonReader::ExtensionReaderContext& context) {
  (void)context;
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TilesetJsonHandler.h"

#include <Cesium3DTiles/Tileset.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

TilesetJsonHandler::TilesetJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _asset(context),
      _properties(context),
      _geometricError(),
      _root(context),
      _extensionsUsed(),
      _extensionsRequired() {}

void TilesetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Tileset* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TilesetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTileset(
      Cesium3DTiles::Tileset::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TilesetJsonHandler::readObjectKeyTileset(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Tileset& o) {
  using namespace std::string_literals;

  if ("asset"s == str)
    return property("asset", this->_asset, o.asset);
  if ("properties"s == str)
    return property("properties", this->_properties, o.properties);
  if ("geometricError"s == str)
    return property("geometricError", this->_geometricError, o.geometricError);
  if ("root"s == str)
    return property("root", this->_root, o.root);
  if ("extensionsUsed"s == str)
    return property("extensionsUsed", this->_extensionsUsed, o.extensionsUsed);
  if ("extensionsRequired"s == str)
    return property(
        "extensionsRequired",
        this->_extensionsRequired,
        o.extensionsRequired);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

void TilesetJsonHandler::populateExtensions(
    CesiumJsonReader::ExtensionReaderContext& context) {

  context.registerExtension<
      Cesium3DTiles::Tileset,
      Extension3dTilesContentGltfJsonHandler>();
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "TileJsonHandler.h"

#include <Cesium3DTiles/Tile.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

TileJsonHandler::TileJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _boundingVolume(context),
      _viewerRequestVolume(context),
      _geometricError(),
      _refine(),
      _transform(),
      _content(context),
      _children(context) {}

void TileJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Tile* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
TileJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyTile(
      Cesium3DTiles::Tile::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* TileJsonHandler::readObjectKeyTile(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Tile& o) {
  using namespace std::string_literals;

  if ("boundingVolume"s == str)
    return property("boundingVolume", this->_boundingVolume, o.boundingVolume);
  if ("viewerRequestVolume"s == str)
    return property(
        "viewerRequestVolume",
        this->_viewerRequestVolume,
        o.viewerRequestVolume);
  if ("geometricError"s == str)
    return property("geometricError", this->_geometricError, o.geometricError);
  if ("refine"s == str)
    return property("refine", this->_refine, o.refine);
  if ("transform"s == str)
    return property("transform", this->_transform, o.transform);
  if ("content"s == str)
    return property("content", this->_content, o.content);
  if ("children"s == str)
    return property("children", this->_children, o.children);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

void TileJsonHandler::populateExtensions(
    CesiumJsonReader::ExtensionReaderContext& context) {
  (void)context;
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "ContentJsonHandler.h"

#include <Cesium3DTiles/Content.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

ContentJsonHandler::ContentJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _boundingVolume(context),
      _uri() {}

void ContentJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Content* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
ContentJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyContent(
      Cesium3DTiles::Content::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* ContentJsonHandler::readObjectKeyContent(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Content& o) {
  using namespace std::string_literals;

  if ("boundingVolume"s == str)
    return property("boundingVolume", this->_boundingVolume, o.boundingVolume);
  if ("uri"s == str)
    return property("uri", this->_uri, o.uri);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

void ContentJsonHandler::populateExtensions(
    CesiumJsonReader::ExtensionReaderContext& context) {
  (void)context;
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "BoundingVolumeJsonHandler.h"

#include <Cesium3DTiles/BoundingVolume.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

BoundingVolumeJsonHandler::BoundingVolumeJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _box(),
      _region(),
      _sphere() {}

void BoundingVolumeJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::BoundingVolume* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
BoundingVolumeJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyBoundingVolume(
      Cesium3DTiles::BoundingVolume::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler*
BoundingVolumeJsonHandler::readObjectKeyBoundingVolume(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::BoundingVolume& o) {
  using namespace std::string_literals;

  if ("box"s == str)
    return property("box", this->_box, o.box);
  if ("region"s == str)
    return property("region", this->_region, o.region);
  if ("sphere"s == str)
    return property("sphere", this->_sphere, o.sphere);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

void BoundingVolumeJsonHandler::populateExtensions(
    CesiumJsonReader::ExtensionReaderContext& context) {
  (void)context;
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "PropertiesJsonHandler.h"

#include <Cesium3DTiles/Properties.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

PropertiesJsonHandler::PropertiesJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _maximum(),
      _minimum() {}

void PropertiesJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Properties* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
PropertiesJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyProperties(
      Cesium3DTiles::Properties::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* PropertiesJsonHandler::readObjectKeyProperties(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Properties& o) {
  using namespace std::string_literals;

  if ("maximum"s == str)
    return property("maximum", this->_maximum, o.maximum);
  if ("minimum"s == str)
    return property("minimum", this->_minimum, o.minimum);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

void PropertiesJsonHandler::populateExtensions(
    CesiumJsonReader::ExtensionReaderContext& context) {
  (void)context;
}

} // namespace Cesium3DTilesReader
// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#include "AssetJsonHandler.h"

#include <Cesium3DTiles/Asset.h>

#include <cassert>
#include <string>

namespace Cesium3DTilesReader {

AssetJsonHandler::AssetJsonHandler(
    const CesiumJsonReader::ExtensionReaderContext& context) noexcept
    : CesiumJsonReader::ExtensibleObjectJsonHandler(context),
      _version(),
      _tilesetVersion() {}

void AssetJsonHandler::reset(
    CesiumJsonReader::IJsonHandler* pParentHandler,
    Cesium3DTiles::Asset* pObject) {
  CesiumJsonReader::ExtensibleObjectJsonHandler::reset(pParentHandler, pObject);
  this->_pObject = pObject;
}

CesiumJsonReader::IJsonHandler*
AssetJsonHandler::readObjectKey(const std::string_view& str) {
  assert(this->_pObject);
  return this->readObjectKeyAsset(
      Cesium3DTiles::Asset::TypeName,
      str,
      *this->_pObject);
}

CesiumJsonReader::IJsonHandler* AssetJsonHandler::readObjectKeyAsset(
    const std::string& objectType,
    const std::string_view& str,
    Cesium3DTiles::Asset& o) {
  using namespace std::string_literals;

  if ("version"s == str)
    return property("version", this->_version, o.version);
  if ("tilesetVersion"s == str)
    return property("tilesetVersion", this->_tilesetVersion, o.tilesetVersion);

  return this->readObjectKeyExtensibleObject(objectType, str, *this->_pObject);
}

void AssetJsonHandler::populateExtensions(
    CesiumJsonReader::ExtensionReaderContext& context) {
  (void)context;
}

} // namespace Cesium3DTilesReader
