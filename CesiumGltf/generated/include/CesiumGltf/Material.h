// This file was generated by generate-classes.
// DO NOT EDIT THIS FILE!
#pragma once

#include <CesiumGltf/Library.h>
#include <CesiumGltf/MaterialNormalTextureInfo.h>
#include <CesiumGltf/MaterialOcclusionTextureInfo.h>
#include <CesiumGltf/MaterialPBRMetallicRoughness.h>
#include <CesiumGltf/NamedObject.h>
#include <CesiumGltf/TextureInfo.h>

#include <optional>
#include <string>
#include <vector>

namespace CesiumGltf {
/**
 * @brief The material appearance of a primitive.
 */
struct CESIUMGLTF_API Material final : public CesiumGltf::NamedObject {
  /**
   * @brief The original name of this type.
   */
  static constexpr const char* TypeName = "Material";

  /**
   * @brief Known values for The alpha rendering mode of the material.
   */
  struct AlphaMode {
    /** @brief The alpha value is ignored, and the rendered output is fully
     * opaque. */
    inline static const std::string OPAQUE = "OPAQUE";

    /** @brief The rendered output is either fully opaque or fully transparent
     * depending on the alpha value and the specified `alphaCutoff` value; the
     * exact appearance of the edges **MAY** be subject to
     * implementation-specific techniques such as "`Alpha-to-Coverage`". */
    inline static const std::string MASK = "MASK";

    /** @brief The alpha value is used to composite the source and destination
     * areas. The rendered output is combined with the background using the
     * normal painting operation (i.e. the Porter and Duff over operator). */
    inline static const std::string BLEND = "BLEND";
  };

  /**
   * @brief A set of parameter values that are used to define the
   * metallic-roughness material model from Physically Based Rendering (PBR)
   * methodology. When undefined, all the default values of
   * `pbrMetallicRoughness` **MUST** apply.
   */
  std::optional<CesiumGltf::MaterialPBRMetallicRoughness> pbrMetallicRoughness;

  /**
   * @brief The tangent space normal texture.
   *
   * The texture encodes RGB components with linear transfer function. Each
   * texel represents the XYZ components of a normal vector in tangent space.
   * The normal vectors use the convention +X is right and +Y is up. +Z points
   * toward the viewer. If a fourth component (A) is present, it **MUST** be
   * ignored. When undefined, the material does not have a tangent space normal
   * texture.
   */
  std::optional<CesiumGltf::MaterialNormalTextureInfo> normalTexture;

  /**
   * @brief The occlusion texture.
   *
   * The occlusion values are linearly sampled from the R channel. Higher values
   * indicate areas that receive full indirect lighting and lower values
   * indicate no indirect lighting. If other channels are present (GBA), they
   * **MUST** be ignored for occlusion calculations. When undefined, the
   * material does not have an occlusion texture.
   */
  std::optional<CesiumGltf::MaterialOcclusionTextureInfo> occlusionTexture;

  /**
   * @brief The emissive texture.
   *
   * It controls the color and intensity of the light being emitted by the
   * material. This texture contains RGB components encoded with the sRGB
   * transfer function. If a fourth component (A) is present, it **MUST** be
   * ignored. When undefined, the texture **MUST** be sampled as having `1.0` in
   * RGB components.
   */
  std::optional<CesiumGltf::TextureInfo> emissiveTexture;

  /**
   * @brief The factors for the emissive color of the material.
   *
   * This value defines linear multipliers for the sampled texels of the
   * emissive texture.
   */
  std::vector<double> emissiveFactor = {0, 0, 0};

  /**
   * @brief The alpha rendering mode of the material.
   *
   * Known values are defined in {@link AlphaMode}.
   *
   *
   * The material's alpha rendering mode enumeration specifying the
   * interpretation of the alpha value of the base color.
   */
  std::string alphaMode = AlphaMode::OPAQUE;

  /**
   * @brief The alpha cutoff value of the material.
   *
   * Specifies the cutoff threshold when in `MASK` alpha mode. If the alpha
   * value is greater than or equal to this value then it is rendered as fully
   * opaque, otherwise, it is rendered as fully transparent. A value greater
   * than `1.0` will render the entire material as fully transparent. This value
   * **MUST** be ignored for other alpha modes. When `alphaMode` is not defined,
   * this value **MUST NOT** be defined.
   */
  double alphaCutoff = 0.5;

  /**
   * @brief Specifies whether the material is double sided.
   *
   * When this value is false, back-face culling is enabled. When this value is
   * true, back-face culling is disabled and double-sided lighting is enabled.
   * The back-face **MUST** have its normals reversed before the lighting
   * equation is evaluated.
   */
  bool doubleSided = false;

  /**
   * @brief Calculates the size in bytes of this object, including the contents
   * of all collections, pointers, and strings. This will NOT include the size
   * of any extensions attached to the object. Calling this method may be slow
   * as it requires traversing the object's entire structure.
   */
  int64_t getSizeBytes() const {
    int64_t accum = 0;
    accum += int64_t(sizeof(Material));
    accum += CesiumGltf::NamedObject::getSizeBytes() -
             int64_t(sizeof(CesiumGltf::NamedObject));
    if (this->pbrMetallicRoughness) {
      accum += this->pbrMetallicRoughness->getSizeBytes() -
               int64_t(sizeof(CesiumGltf::MaterialPBRMetallicRoughness));
    }
    if (this->normalTexture) {
      accum += this->normalTexture->getSizeBytes() -
               int64_t(sizeof(CesiumGltf::MaterialNormalTextureInfo));
    }
    if (this->occlusionTexture) {
      accum += this->occlusionTexture->getSizeBytes() -
               int64_t(sizeof(CesiumGltf::MaterialOcclusionTextureInfo));
    }
    if (this->emissiveTexture) {
      accum += this->emissiveTexture->getSizeBytes() -
               int64_t(sizeof(CesiumGltf::TextureInfo));
    }
    accum += int64_t(sizeof(double) * this->emissiveFactor.capacity());
    return accum;
  }
};
} // namespace CesiumGltf
