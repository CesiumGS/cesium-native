// This file was generated by generate-gltf-classes.
// DO NOT EDIT THIS FILE!
#pragma once

#include "CesiumGltf/Library.h"
#include "CesiumGltf/MaterialNormalTextureInfo.h"
#include "CesiumGltf/MaterialOcclusionTextureInfo.h"
#include "CesiumGltf/MaterialPBRMetallicRoughness.h"
#include "CesiumGltf/NamedObject.h"
#include "CesiumGltf/TextureInfo.h"
#include <optional>
#include <vector>

namespace CesiumGltf {
/**
 * @brief The material appearance of a primitive.
 */
struct CESIUMGLTF_API Material final : public NamedObject {
  static constexpr const char* TypeName = "Material";

  /**
   * @brief The alpha rendering mode of the material.
   *
   * The material's alpha rendering mode enumeration specifying the
   * interpretation of the alpha value of the main factor and texture.
   */
  enum class AlphaMode {
    OPAQUE,

    MASK,

    BLEND
  };

  /**
   * @brief A set of parameter values that are used to define the
   * metallic-roughness material model from Physically-Based Rendering (PBR)
   * methodology. When not specified, all the default values of
   * `pbrMetallicRoughness` apply.
   */
  std::optional<MaterialPBRMetallicRoughness> pbrMetallicRoughness;

  /**
   * @brief The normal map texture.
   *
   * A tangent space normal map. The texture contains RGB components in linear
   * space. Each texel represents the XYZ components of a normal vector in
   * tangent space. Red [0 to 255] maps to X [-1 to 1]. Green [0 to 255] maps to
   * Y [-1 to 1]. Blue [128 to 255] maps to Z [1/255 to 1]. The normal vectors
   * use the convention +X is right and +Y is up. +Z points toward the viewer.
   * In GLSL, this vector would be unpacked like so: `vec3 normalVector =
   * tex2D(<sampled normal map texture value>, texCoord) * 2 - 1`. Client
   * implementations should normalize the normal vectors before using them in
   * lighting equations.
   */
  std::optional<MaterialNormalTextureInfo> normalTexture;

  /**
   * @brief The occlusion map texture.
   *
   * The occlusion values are sampled from the R channel. Higher values indicate
   * areas that should receive full indirect lighting and lower values indicate
   * no indirect lighting. These values are linear. If other channels are
   * present (GBA), they are ignored for occlusion calculations.
   */
  std::optional<MaterialOcclusionTextureInfo> occlusionTexture;

  /**
   * @brief The emissive map texture.
   *
   * The emissive map controls the color and intensity of the light being
   * emitted by the material. This texture contains RGB components encoded with
   * the sRGB transfer function. If a fourth component (A) is present, it is
   * ignored.
   */
  std::optional<TextureInfo> emissiveTexture;

  /**
   * @brief The emissive color of the material.
   *
   * The RGB components of the emissive color of the material. These values are
   * linear. If an emissiveTexture is specified, this value is multiplied with
   * the texel values.
   */
  std::vector<double> emissiveFactor = {0, 0, 0};

  /**
   * @brief The alpha rendering mode of the material.
   *
   * The material's alpha rendering mode enumeration specifying the
   * interpretation of the alpha value of the main factor and texture.
   */
  AlphaMode alphaMode = AlphaMode::OPAQUE;

  /**
   * @brief The alpha cutoff value of the material.
   *
   * Specifies the cutoff threshold when in `MASK` mode. If the alpha value is
   * greater than or equal to this value then it is rendered as fully opaque,
   * otherwise, it is rendered as fully transparent. A value greater than 1.0
   * will render the entire material as fully transparent. This value is ignored
   * for other modes.
   */
  double alphaCutoff = 0.5;

  /**
   * @brief Specifies whether the material is double sided.
   *
   * When this value is false, back-face culling is enabled. When this value is
   * true, back-face culling is disabled and double sided lighting is enabled.
   * The back-face must have its normals reversed before the lighting equation
   * is evaluated.
   */
  bool doubleSided = false;
};
} // namespace CesiumGltf
